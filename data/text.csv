,1,2,label
0,구슬 탈출 2,"스타트링크에서 판매하는 어린이용 장난감 중에서 가장 인기가 많은 제품은 구슬 탈출이다. 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다. 보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다. 가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다. 빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다. 게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다. 이때, 구슬을 손으로 건드릴 수는 없고, 중력을 이용해서 이리 저리 굴려야 한다. 왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다. 각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다. 또, 빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다. 보드의 상태가 주어졌을 때, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 프로그램을 작성하시오.",0
1,2048 (Easy),"2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다. 이 링크를 누르면 게임을 해볼 수 있다. 이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다) <그림 1> <그림 2> <그림 3> <그림 1>의 경우에서 위로 블록을 이동시키면 <그림 2>의 상태가 된다. 여기서, 왼쪽으로 블록을 이동시키면 <그림 3>의 상태가 된다. <그림 4> <그림 5> <그림 6> <그림 7> <그림 4>의 상태에서 블록을 오른쪽으로 이동시키면 <그림 5>가 되고, 여기서 다시 위로 블록을 이동시키면 <그림 6>이 된다. 여기서 오른쪽으로 블록을 이동시켜 <그림 7>을 만들 수 있다. <그림 8> <그림 9> <그림 8>의 상태에서 왼쪽으로 블록을 옮기면 어떻게 될까? 2가 충돌하기 때문에, 4로 합쳐지게 되고 <그림 9>의 상태가 된다. <그림 10> <그림 11> <그림 12> <그림 13> <그림 10>에서 위로 블록을 이동시키면 <그림 11>의 상태가 된다. <그림 12>의 경우에 위로 블록을 이동시키면 <그림 13>의 상태가 되는데, 그 이유는 한 번의 이동에서 이미 합쳐진 블록은 또 합쳐질 수 없기 때문이다. <그림 14> <그림 15> 마지막으로, 똑같은 수가 세 개가 있는 경우에는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 예를 들어, 위로 이동시키는 경우에는 위쪽에 있는 블록이 먼저 합쳐지게 된다. <그림 14>의 경우에 위로 이동하면 <그림 15>를 만든다. 이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다. 보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.",0
2,뱀,"'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다. 게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다. 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다. 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다. 만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다. 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다. 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다. 사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.",0
3,시험 감독,"총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다. 감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다. 각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다. 각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.",0
4,주사위 굴리기,"크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 2 4 1 3 5 6 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다. 지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다. 주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오. 주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.",0
5,테트로미노,"폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다. 정사각형은 서로 겹치면 안 된다. 도형은 모두 연결되어 있어야 한다. 정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다. 정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다. 아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.",0
6,퇴사,"상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다. 오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다. 백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다. 각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다. N = 7인 경우에 다음과 같은 상담 일정표를 보자. 1일 2일 3일 4일 5일 6일 7일 Ti 3 5 1 1 2 4 2 Pi 10 20 10 20 15 40 200 1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다. 상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다. 또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다. 퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다. 상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.",0
7,연구소,"인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다. 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 2 0 0 0 1 1 0 0 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다. 2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다. 2 1 0 0 1 1 0 1 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 바이러스가 퍼진 뒤의 모습은 아래와 같아진다. 2 1 0 0 1 1 2 1 0 1 0 1 2 2 0 1 1 0 1 2 2 0 1 0 0 0 1 2 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다. 연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.",0
8,로봇 청소기,"로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오. 로봇 청소기가 있는 방은 $N \times M$ 크기의 직사각형으로 나타낼 수 있으며, $1 \times 1$ 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 $(r, c)$로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가 $(0, 0)$, 가장 남쪽 줄의 가장 동쪽 칸의 좌표가 $(N-1, M-1)$이다. 즉, 좌표 $(r, c)$는 북쪽에서 $(r+1)$번째에 있는 줄의 서쪽에서 $(c+1)$번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다. 로봇 청소기는 다음과 같이 작동한다. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다. 현재 칸의 주변 $4$칸 중 청소되지 않은 빈 칸이 없는 경우, 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다. 현재 칸의 주변 $4$칸 중 청소되지 않은 빈 칸이 있는 경우, 반시계 방향으로 $90^\circ$ 회전한다. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다. 1번으로 돌아간다.",0
9,연산자 끼워넣기,"N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다. 예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다. 1+2+3-4×5÷6 1÷2+3+4-5×6 1+2÷3×4-5+6 1÷2×3-4+5+6 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다. 1+2+3-4×5÷6 = 1 1÷2+3+4-5×6 = 12 1+2÷3×4-5+6 = 5 1÷2×3-4+5+6 = 7 N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.",0
10,스타트와 링크,"오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다. BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다. N=4이고, S가 아래와 같은 경우를 살펴보자. i\j 1 2 3 4 1 1 2 3 2 4 5 6 3 7 1 2 4 3 4 5 예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다. 스타트 팀: S12 + S21 = 1 + 4 = 5 링크 팀: S34 + S43 = 2 + 5 = 7 1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다. 스타트 팀: S13 + S31 = 2 + 7 = 9 링크 팀: S24 + S42 = 6 + 4 = 10 축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.",0
11,경사로,"크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. 오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. 다음과 같은 N=6인 경우 지도를 살펴보자. 이때, 길은 총 2N개가 있으며, 아래와 같다. 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다. 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다. 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다. 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다. 아래와 같은 경우에는 경사로를 놓을 수 없다. 경사로를 놓은 곳에 또 경사로를 놓는 경우 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우 경사로를 놓다가 범위를 벗어나는 경우 L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다. 경사로를 놓을 수 없는 경우는 아래와 같다. 위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다. 가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다. 지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.",0
12,톱니바퀴,"총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다. 이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다. 톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자. 두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다. 위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다. 톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.",0
13,감시,"스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다. 1번 2번 3번 4번 5번 1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다. CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다. CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0 지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0 0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0 → ← ↑ ↓ CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다. 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 6 0 0 6 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 5 위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다. 0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔ 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕ 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔ 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕ CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자. 0 0 2 0 3 0 6 0 0 0 0 0 6 6 0 0 0 0 0 0 위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다. # # 2 # 3 0 6 # 0 # 0 0 6 6 # 0 0 0 0 # 사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.",0
14,사다리 조작,"사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다. 초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다. 위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다. 사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다. 위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다. 1번 세로선 2번 세로선 사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.",0
15,드래곤 커브,"드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다. 시작 점 시작 방향 세대 0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다. 1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다. 2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다) 3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다. 즉, K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다. 크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.",0
16,치킨 배달,"크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다. 이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 ""치킨 거리""라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다. 임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다. 예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자. 0 2 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 2 0은 빈 칸, 1은 집, 2는 치킨집이다. (2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다. (5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다. 이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는 치킨집의 개수는 최대 M개라는 사실을 알아내었다. 도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.",0
17,큐빙,"루빅스 큐브는 삼차원 퍼즐이다. 보통 루빅스 큐브는 3×3×3개의 작은 정육면체로 이루어져 있다. 퍼즐을 풀려면 각 면에 있는 아홉 개의 작은 정육면체의 색이 동일해야 한다. 큐브는 각 면을 양방향으로 90도 만큼 돌릴 수 있도록 만들어져 있다. 회전이 마친 이후에는, 다른 면을 돌릴 수 있다. 이렇게 큐브의 서로 다른 면을 돌리다 보면, 색을 섞을 수 있다. 이 문제에서는 루빅스 큐브가 모두 풀린 상태에서 시작한다. 윗 면은 흰색, 아랫 면은 노란색, 앞 면은 빨간색, 뒷 면은 오렌지색, 왼쪽 면은 초록색, 오른쪽 면은 파란색이다. 루빅스 큐브를 돌린 방법이 순서대로 주어진다. 이때, 모두 돌린 다음에 가장 윗 면의 색상을 구하는 프로그램을 작성하시오. 위의 그림은 루빅스 큐브를 푼 그림이다. 왼쪽 면은 시계방향으로 조금 돌려져 있는 상태이다.",0
18,인구 이동,"N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다. 오늘부터 인구 이동이 시작되는 날이다. 인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다. 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다. 연합을 해체하고, 모든 국경선을 닫는다. 각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오.",0
19,나무 재테크,"부동산 투자로 억대의 돈을 번 상도는 최근 N×N 크기의 땅을 구매했다. 상도는 손쉬운 땅 관리를 위해 땅을 1×1 크기의 칸으로 나누어 놓았다. 각각의 칸은 (r, c)로 나타내며, r은 가장 위에서부터 떨어진 칸의 개수, c는 가장 왼쪽으로부터 떨어진 칸의 개수이다. r과 c는 1부터 시작한다. 상도는 전자통신공학과 출신답게 땅의 양분을 조사하는 로봇 S2D2를 만들었다. S2D2는 1×1 크기의 칸에 들어있는 양분을 조사해 상도에게 전송하고, 모든 칸에 대해서 조사를 한다. 가장 처음에 양분은 모든 칸에 5만큼 들어있다. 매일 매일 넓은 땅을 보면서 뿌듯한 하루를 보내고 있던 어느 날 이런 생각이 들었다. 나무 재테크를 하자! 나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다. 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의 칸에 여러 개의 나무가 심어져 있을 수도 있다. 이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다. 봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다. 여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다. 가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다. 겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다. K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성하시오.",0
20,아기 상어,"N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다. 아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다. 아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다. 아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다. 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다. 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다. 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다. 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다. 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다. 아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다. 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다. 공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.",0
21,미세먼지 안녕!,"미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다. 공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 Ar,c이다. 1초 동안 아래 적힌 일이 순서대로 일어난다. 미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다. (r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다. 인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다. 확산되는 양은 Ar,c/5이고 소수점은 버린다. 즉, ⌊Ar,c/5⌋이다. (r, c)에 남은 미세먼지의 양은 Ar,c - ⌊Ar,c/5⌋×(확산된 방향의 개수) 이다. 공기청정기가 작동한다. 공기청정기에서는 바람이 나온다. 위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다. 바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다. 공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다. 다음은 확산의 예시이다. 왼쪽과 위쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다. 인접한 네 방향으로 모두 확산이 일어난다. 공기청정기가 있는 칸으로는 확산이 일어나지 않는다. 공기청정기의 바람은 다음과 같은 방향으로 순환한다. 방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.",0
22,낚시왕,"낚시왕이 상어 낚시를 하는 곳은 크기가 R×C인 격자판으로 나타낼 수 있다. 격자판의 각 칸은 (r, c)로 나타낼 수 있다. r은 행, c는 열이고, (R, C)는 아래 그림에서 가장 오른쪽 아래에 있는 칸이다. 칸에는 상어가 최대 한 마리 들어있을 수 있다. 상어는 크기와 속도를 가지고 있다. 낚시왕은 처음에 1번 열의 한 칸 왼쪽에 있다. 다음은 1초 동안 일어나는 일이며, 아래 적힌 순서대로 일어난다. 낚시왕은 가장 오른쪽 열의 오른쪽 칸에 이동하면 이동을 멈춘다. 낚시왕이 오른쪽으로 한 칸 이동한다. 낚시왕이 있는 열에 있는 상어 중에서 땅과 제일 가까운 상어를 잡는다. 상어를 잡으면 격자판에서 잡은 상어가 사라진다. 상어가 이동한다. 상어는 입력으로 주어진 속도로 이동하고, 속도의 단위는 칸/초이다. 상어가 이동하려고 하는 칸이 격자판의 경계를 넘는 경우에는 방향을 반대로 바꿔서 속력을 유지한채로 이동한다. 왼쪽 그림의 상태에서 1초가 지나면 오른쪽 상태가 된다. 상어가 보고 있는 방향이 속도의 방향, 왼쪽 아래에 적힌 정수는 속력이다. 왼쪽 위에 상어를 구분하기 위해 문자를 적었다. 상어가 이동을 마친 후에 한 칸에 상어가 두 마리 이상 있을 수 있다. 이때는 크기가 가장 큰 상어가 나머지 상어를 모두 잡아먹는다. 낚시왕이 상어 낚시를 하는 격자판의 상태가 주어졌을 때, 낚시왕이 잡은 상어 크기의 합을 구해보자.",0
23,이차원 배열과 연산,"크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다. R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다. C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다. 한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다. 예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다. 정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다. 행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다. 배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.",0
24,연구소 3,"인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다. 연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다. 예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다. 2 0 0 0 1 1 0 0 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 2 0 1 1 0 1 0 0 0 0 0 2 1 0 0 0 0 2 M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다. * 6 5 4 - - 2 5 6 - 3 - 0 1 4 - - 2 - 1 2 3 - 2 1 2 2 3 2 2 1 0 1 - - 1 - 2 1 2 3 4 0 - 3 2 3 4 * 시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다. 0 1 2 3 - - 2 1 2 - 3 - 0 1 2 - - 2 - 1 2 3 - 2 1 2 2 3 3 2 1 0 1 - - 4 - 2 1 2 3 4 * - 3 2 3 4 * 연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.",0
25,게리맨더링 2,"재현시의 시장 구재현은 지난 몇 년간 게리맨더링을 통해서 자신의 당에게 유리하게 선거구를 획정했다. 견제할 권력이 없어진 구재현은 권력을 매우 부당하게 행사했고, 심지어는 시의 이름도 재현시로 변경했다. 이번 선거에서는 최대한 공평하게 선거구를 획정하려고 한다. 재현시는 크기가 N×N인 격자로 나타낼 수 있다. 격자의 각 칸은 구역을 의미하고, r행 c열에 있는 구역은 (r, c)로 나타낼 수 있다. 구역을 다섯 개의 선거구로 나눠야 하고, 각 구역은 다섯 선거구 중 하나에 포함되어야 한다. 선거구는 구역을 적어도 하나 포함해야 하고, 한 선거구에 포함되어 있는 구역은 모두 연결되어 있어야 한다. 구역 A에서 인접한 구역을 통해서 구역 B로 갈 수 있을 때, 두 구역은 연결되어 있다고 한다. 중간에 통하는 인접한 구역은 0개 이상이어야 하고, 모두 같은 선거구에 포함된 구역이어야 한다. 선거구를 나누는 방법은 다음과 같다. 기준점 (x, y)와 경계의 길이 d1, d2를 정한다. (d1, d2 ≥ 1, 1 ≤ x < x+d1+d2 ≤ N, 1 ≤ y-d1 < y < y+d2 ≤ N) 다음 칸은 경계선이다. (x, y), (x+1, y-1), ..., (x+d1, y-d1) (x, y), (x+1, y+1), ..., (x+d2, y+d2) (x+d1, y-d1), (x+d1+1, y-d1+1), ... (x+d1+d2, y-d1+d2) (x+d2, y+d2), (x+d2+1, y+d2-1), ..., (x+d2+d1, y+d2-d1) 경계선과 경계선의 안에 포함되어있는 곳은 5번 선거구이다. 5번 선거구에 포함되지 않은 구역 (r, c)의 선거구 번호는 다음 기준을 따른다. 1번 선거구: 1 ≤ r < x+d1, 1 ≤ c ≤ y 2번 선거구: 1 ≤ r ≤ x+d2, y < c ≤ N 3번 선거구: x+d1 ≤ r ≤ N, 1 ≤ c < y-d1+d2 4번 선거구: x+d2 < r ≤ N, y-d1+d2 ≤ c ≤ N 아래는 크기가 7×7인 재현시를 다섯 개의 선거구로 나눈 방법의 예시이다. x = 2, y = 4, d1 = 2, d2 = 2 x = 2, y = 5, d1 = 3, d2 = 2 x = 4, y = 3, d1 = 1, d2 = 1 구역 (r, c)의 인구는 A[r][c]이고, 선거구의 인구는 선거구에 포함된 구역의 인구를 모두 합한 값이다. 선거구를 나누는 방법 중에서, 인구가 가장 많은 선거구와 가장 적은 선거구의 인구 차이의 최솟값을 구해보자.",0
26,새로운 게임 2,"재현이는 주변을 살펴보던 중 체스판과 말을 이용해서 새로운 게임을 만들기로 했다. 새로운 게임은 크기가 N×N인 체스판에서 진행되고, 사용하는 말의 개수는 K개이다. 말은 원판모양이고, 하나의 말 위에 다른 말을 올릴 수 있다. 체스판의 각 칸은 흰색, 빨간색, 파란색 중 하나로 색칠되어있다. 게임은 체스판 위에 말 K개를 놓고 시작한다. 말은 1번부터 K번까지 번호가 매겨져 있고, 이동 방향도 미리 정해져 있다. 이동 방향은 위, 아래, 왼쪽, 오른쪽 4가지 중 하나이다. 턴 한 번은 1번 말부터 K번 말까지 순서대로 이동시키는 것이다. 한 말이 이동할 때 위에 올려져 있는 말도 함께 이동한다. 말의 이동 방향에 있는 칸에 따라서 말의 이동이 다르며 아래와 같다. 턴이 진행되던 중에 말이 4개 이상 쌓이는 순간 게임이 종료된다. A번 말이 이동하려는 칸이 흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다. A번 말의 위에 다른 말이 있는 경우에는 A번 말과 위에 있는 모든 말이 이동한다. 예를 들어, A, B, C로 쌓여있고, 이동하려는 칸에 D, E가 있는 경우에는 A번 말이 이동한 후에는 D, E, A, B, C가 된다. 빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다. A, B, C가 이동하고, 이동하려는 칸에 말이 없는 경우에는 C, B, A가 된다. A, D, F, G가 이동하고, 이동하려는 칸에 말이 E, C, B로 있는 경우에는 E, C, B, G, F, D, A가 된다. 파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다. 방향을 반대로 바꾼 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 가만히 있는다. 체스판을 벗어나는 경우에는 파란색과 같은 경우이다. 다음은 크기가 4×4인 체스판 위에 말이 4개 있는 경우이다. 첫 번째 턴은 다음과 같이 진행된다. 두 번째 턴은 다음과 같이 진행된다. 체스판의 크기와 말의 위치, 이동 방향이 모두 주어졌을 때, 게임이 종료되는 턴의 번호를 구해보자.",0
27,원판 돌리기,"반지름이 1, 2, ..., N인 원판이 크기가 작아지는 순으로 바닥에 놓여있고, 원판의 중심은 모두 같다. 원판의 반지름이 i이면, 그 원판을 i번째 원판이라고 한다. 각각의 원판에는 M개의 정수가 적혀있고, i번째 원판에 적힌 j번째 수의 위치는 (i, j)로 표현한다. 수의 위치는 다음을 만족한다. (i, 1)은 (i, 2), (i, M)과 인접하다. (i, M)은 (i, M-1), (i, 1)과 인접하다. (i, j)는 (i, j-1), (i, j+1)과 인접하다. (2 ≤ j ≤ M-1) (1, j)는 (2, j)와 인접하다. (N, j)는 (N-1, j)와 인접하다. (i, j)는 (i-1, j), (i+1, j)와 인접하다. (2 ≤ i ≤ N-1) 아래 그림은 N = 3, M = 4인 경우이다. 원판의 회전은 독립적으로 이루어진다. 2번 원판을 회전했을 때, 나머지 원판은 회전하지 않는다. 원판을 회전시킬 때는 수의 위치를 기준으로 하며, 회전시킨 후의 수의 위치는 회전시키기 전과 일치해야 한다. 다음 그림은 원판을 회전시킨 예시이다. 1번 원판을 시계 방향으로 1칸 회전 2, 3번 원판을 반시계 방향으로 3칸 회전 1, 3번 원판을 시계 방향으로 2칸 회전 원판을 아래와 같은 방법으로 총 T번 회전시키려고 한다. 원판의 회전 방법은 미리 정해져 있고, i번째 회전할때 사용하는 변수는 xi, di, ki이다. 번호가 xi의 배수인 원판을 di방향으로 ki칸 회전시킨다. di가 0인 경우는 시계 방향, 1인 경우는 반시계 방향이다. 원판에 수가 남아 있으면, 인접하면서 수가 같은 것을 모두 찾는다. 그러한 수가 있는 경우에는 원판에서 인접하면서 같은 수를 모두 지운다. 없는 경우에는 원판에 적힌 수의 평균을 구하고, 평균보다 큰 수에서 1을 빼고, 작은 수에는 1을 더한다. 원판을 T번 회전시킨 후 원판에 적힌 수의 합을 구해보자.",0
28,주사위 윷놀이,"주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다. 처음에는 시작 칸에 말 4개가 있다. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다. 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다. 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다. 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다. 주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.",0
29,모노미노도미노 2,"모노미노도미노는 아래와 같이 생긴 보드에서 진행되는 게임이다. 보드는 빨간색 보드, 파란색 보드, 초록색 보드가 그림과 같이 붙어있는 형태이다. 게임에서 사용하는 좌표 (x, y)에서 x는 행, y는 열을 의미한다. 빨간색, 파란색, 초록색 보드가 사용하는 좌표는 그 색으로 그림에 적혀있다. <그림 1> 모노미노도미노 게임 보드 이 게임에서 사용하는 블록은 타일 하나 또는 두 개가 가로 또는 세로로 붙어있는 형태이다. 아래와 같이 세 종류가 있으며, 왼쪽부터 순서대로 크기가 1×1, 1×2, 2×1 이다. <그림 2> 모노미노도미노 게임에서 사용하는 블록 블록을 놓을 위치를 빨간색 보드에서 선택하면, 그 위치부터 초록색 보드로 블록이 이동하고, 파란색 보드로 블록이 이동한다. 블록의 이동은 다른 블록을 만나거나 보드의 경계를 만나기 전까지 계속해서 이동한다. 예를 들어, 크기가 1×1인 블록을 (1, 1)에 놓으면, 보드의 상태는 <그림 3>과 같이 변한다. <그림 3> 여기서 크기가 1×2인 블록을 (3, 0)과 (3, 1)에 놓으면 <그림 4>와 같이 보드의 상태가 변한다. <그림 4> 다시 이 상태에서 크기가 2×1인 블록을 (2, 2), (3, 2)와 (2, 3), (3, 3)에 놓으면 <그림 5>와 같이 변한다. <그림 5> 초록색 보드의 4번 행은 모든 칸이 타일로 가득 차있다. 이렇게 초록색 보드에서 어떤 행이 타일로 가득 차 있다면, 그 행의 타일은 모두 사라진다. 사라진 이후에는 초록색 보드에서 사라진 행의 위에 있는 블록이 사라진 행의 수만큼 아래로 이동한다. 파란색의 경우는 열이 타일로 가득 차 있으면, 그 열의 타일이 모두 사라지며, 사라진 이후에는 파란색 보드에서 사라진 열의 왼쪽에 있는 블록이 사라진 열의 수만큼 오른쪽으로 이동한다. 이렇게 한 행이나 열이 타일로 가득 차서 사라지면 1점을 획득한다. 점수는 사라진 행 또는 열의 수와 같다. 만약, 두 개의 행이 사라지면 2점을 획득하게 되고, 한 행과 한 열이 사라져도 2점을 획득하게 된다. 위의 보드는 아래와 같이 변하고, 1점을 얻는다. <그림 6> 여기서 크기가 2×1인 블록을 (1, 3), (2, 3)에 놓으면 보드는 <그림 7>과 같이 변한다. <그림 7> 초록색 보드의 0, 1번 행과 파란색 보드의 0, 1번 열은 그림에는 연한색으로 표현되어 있는 특별한 칸이다. 초록색 보드의 0, 1번 행에 블록이 있으면, 블록이 있는 행의 수만큼 아래 행에 있는 타일이 사라지고, 초록색 보드의 모든 블록이 사라진 행의 수만큼 아래로 이동하고, 파란색 보드의 0, 1번 열에 블록이 있으면, 블록이 있는 열의 수만큼 오른쪽 열에 있는 타일이 사라지고, 파란색 보드의 모든 블록이 사라진 열의 수만큼 이동하게 된다. 위의 그림은 파란색 보드의 1번 열에 블록이 있기 때문에, 5번 열에 있는 블록이 모두 사라지고, 파란색 보드의 모든 블록이 오른쪽으로 한 칸 이동하게 된다. 따라서, 보드는 <그림 8>과 같이 변하게 된다. <그림 8> 위의 보드에서 1×2인 블록을 (0, 0), (0, 1)에 놓으면 <그림 9>와 같다. <그림 9> 여기서 크기가 2×1인 블록을 (2, 0), (3, 0)에 놓으면 <그림 10>과 같이 변한다. 파란색 보드는 1번 열에 블록이 생겨서 오른쪽으로 한 칸씩 이동한 상태이다. <그림 10> 크기가 2×1인 블록을 (1, 2), (2, 2)에 놓으면, <그림 11>과 같이 변한다. <그림 11> 파란색 보드는 1번 열에 블록이 있기 때문에, 5번 열의 타일이 사라지고 모든 블록이 오른쪽으로 한 칸씩 이동하게 된다. 초록색 보드는 4번 행의 모든 칸에 타일이 있기 때문에, 1점을 얻으면서, 4번 행의 모든 타일이 사라진다. <그림 12> <그림 12>는 <그림 11>의 상태에서 파란색 보드는 모든 블록이 오른쪽으로 한 칸 이동했고, 초록색 보드의 4번 행이 모두 사라진 상태이다. 이제, 초록색 보드에서 사라진 행의 위에 있는 블록이 아래로 한 칸씩 내려와야 한다. 이동한 후의 상태는 <그림 13>과 같다. <그림 13> 행이나 열이 타일로 가득찬 경우와 연한 칸에 블록이 있는 경우가 동시에 발생할 수 있다. 이 경우에는 행이나 열이 타일로 가득 찬 경우가 없을 때까지 점수를 획득하는 과정이 모두 진행된 후, 연한 칸에 블록이 있는 경우를 처리해야 한다. 블록은 보드에 놓인 이후에 다른 블록과 합쳐지지 않는다. 블록을 놓은 위치가 순서대로 주어졌을 때, 얻은 점수와 초록색 보드와 파란색 보드에 타일이 있는 칸의 개수를 모두 구해보자.",0
30,청소년 상어,"아기 상어가 성장해 청소년 상어가 되었다. 4×4크기의 공간이 있고, 크기가 1×1인 정사각형 칸으로 나누어져 있다. 공간의 각 칸은 (x, y)와 같이 표현하며, x는 행의 번호, y는 열의 번호이다. 한 칸에는 물고기가 한 마리 존재한다. 각 물고기는 번호와 방향을 가지고 있다. 번호는 1보다 크거나 같고, 16보다 작거나 같은 자연수이며, 두 물고기가 같은 번호를 갖는 경우는 없다. 방향은 8가지 방향(상하좌우, 대각선) 중 하나이다. 오늘은 청소년 상어가 이 공간에 들어가 물고기를 먹으려고 한다. 청소년 상어는 (0, 0)에 있는 물고기를 먹고, (0, 0)에 들어가게 된다. 상어의 방향은 (0, 0)에 있던 물고기의 방향과 같다. 이후 물고기가 이동한다. 물고기는 번호가 작은 물고기부터 순서대로 이동한다. 물고기는 한 칸을 이동할 수 있고, 이동할 수 있는 칸은 빈 칸과 다른 물고기가 있는 칸, 이동할 수 없는 칸은 상어가 있거나, 공간의 경계를 넘는 칸이다. 각 물고기는 방향이 이동할 수 있는 칸을 향할 때까지 방향을 45도 반시계 회전시킨다. 만약, 이동할 수 있는 칸이 없으면 이동을 하지 않는다. 그 외의 경우에는 그 칸으로 이동을 한다. 물고기가 다른 물고기가 있는 칸으로 이동할 때는 서로의 위치를 바꾸는 방식으로 이동한다. 물고기의 이동이 모두 끝나면 상어가 이동한다. 상어는 방향에 있는 칸으로 이동할 수 있는데, 한 번에 여러 개의 칸을 이동할 수 있다. 상어가 물고기가 있는 칸으로 이동했다면, 그 칸에 있는 물고기를 먹고, 그 물고기의 방향을 가지게 된다. 이동하는 중에 지나가는 칸에 있는 물고기는 먹지 않는다. 물고기가 없는 칸으로는 이동할 수 없다. 상어가 이동할 수 있는 칸이 없으면 공간에서 벗어나 집으로 간다. 상어가 이동한 후에는 다시 물고기가 이동하며, 이후 이 과정이 계속해서 반복된다. <그림 1> <그림 1>은 청소년 상어가 공간에 들어가기 전 초기 상태이다. 상어가 공간에 들어가면 (0, 0)에 있는 7번 물고기를 먹고, 상어의 방향은 ↘이 된다. <그림 2>는 상어가 들어간 직후의 상태를 나타낸다. <그림 2> 이제 물고기가 이동해야 한다. 1번 물고기의 방향은 ↗이다. ↗ 방향에는 칸이 있고, 15번 물고기가 들어있다. 물고기가 있는 칸으로 이동할 때는 그 칸에 있는 물고기와 위치를 서로 바꿔야 한다. 따라서, 1번 물고기가 이동을 마치면 <그림 3>과 같아진다. <그림 3> 2번 물고기의 방향은 ←인데, 그 방향에는 상어가 있으니 이동할 수 없다. 방향을 45도 반시계 회전을 하면 ↙가 되고, 이 칸에는 3번 물고기가 있다. 물고기가 있는 칸이니 서로 위치를 바꾸고, <그림 4>와 같아지게 된다. <그림 4> 3번 물고기의 방향은 ↑이고, 존재하지 않는 칸이다. 45도 반시계 회전을 한 방향 ↖도 존재하지 않으니, 다시 회전을 한다. ← 방향에는 상어가 있으니 또 회전을 해야 한다. ↙ 방향에는 2번 물고기가 있으니 서로의 위치를 교환하면 된다. 이런 식으로 모든 물고기가 이동하면 <그림 5>와 같아진다. <그림 5> 물고기가 모두 이동했으니 이제 상어가 이동할 순서이다. 상어의 방향은 ↘이고, 이동할 수 있는 칸은 12번 물고기가 있는 칸, 15번 물고기가 있는 칸, 8번 물고기가 있는 칸 중에 하나이다. 만약, 8번 물고기가 있는 칸으로 이동하면, <그림 6>과 같아지게 된다. <그림 6> 상어가 먹을 수 있는 물고기 번호의 합의 최댓값을 구해보자.",0
31,어른 상어,"청소년 상어는 더욱 자라 어른 상어가 되었다. 상어가 사는 공간에 더 이상 물고기는 오지 않고 다른 상어들만이 남아있다. 상어에는 1 이상 M 이하의 자연수 번호가 붙어 있고, 모든 번호는 서로 다르다. 상어들은 영역을 사수하기 위해 다른 상어들을 쫓아내려고 하는데, 1의 번호를 가진 어른 상어는 가장 강력해서 나머지 모두를 쫓아낼 수 있다. N×N 크기의 격자 중 M개의 칸에 상어가 한 마리씩 들어 있다. 맨 처음에는 모든 상어가 자신의 위치에 자신의 냄새를 뿌린다. 그 후 1초마다 모든 상어가 동시에 상하좌우로 인접한 칸 중 하나로 이동하고, 자신의 냄새를 그 칸에 뿌린다. 냄새는 상어가 k번 이동하고 나면 사라진다. 각 상어가 이동 방향을 결정할 때는, 먼저 인접한 칸 중 아무 냄새가 없는 칸의 방향으로 잡는다. 그런 칸이 없으면 자신의 냄새가 있는 칸의 방향으로 잡는다. 이때 가능한 칸이 여러 개일 수 있는데, 그 경우에는 특정한 우선순위를 따른다. 우선순위는 상어마다 다를 수 있고, 같은 상어라도 현재 상어가 보고 있는 방향에 따라 또 다를 수 있다. 상어가 맨 처음에 보고 있는 방향은 입력으로 주어지고, 그 후에는 방금 이동한 방향이 보고 있는 방향이 된다. 모든 상어가 이동한 후 한 칸에 여러 마리의 상어가 남아 있으면, 가장 작은 번호를 가진 상어를 제외하고 모두 격자 밖으로 쫓겨난다. <그림 1> 우선 순위 상어 1 상어 2 상어 3 상어 4 ↑ ↓ ← ↑ → ↑ ↓ → ← ↑ ↑ → ← ↓ ↑ ↑ ← → ↑ ↓ ↓ → ↑ ↓ ← ↓ ↓ ↑ ← → ↓ ↑ → ← ↓ ↓ ← ↓ → ↑ ← ← → ↓ ↑ ← ← → ↑ ↓ ← ↑ ← ↓ → ← ↑ → ↓ ← → → ← ↑ ↓ → → ↑ ↓ ← → ← ↓ ↑ → → ↑ → ↓ ← <표 1> <그림 1>은 맨 처음에 모든 상어가 자신의 냄새를 뿌린 상태를 나타내며, <표 1>에는 각 상어 및 현재 방향에 따른 우선순위가 표시되어 있다. 이 예제에서는 k = 4이다. 왼쪽 하단에 적힌 정수는 냄새를 의미하고, 그 값은 사라지기까지 남은 시간이다. 좌측 상단에 적힌 정수는 상어의 번호 또는 냄새를 뿌린 상어의 번호를 의미한다. <그림 2> <그림 3> <그림 2>는 모든 상어가 한 칸 이동하고 자신의 냄새를 뿌린 상태이고, <그림 3>은 <그림 2>의 상태에서 한 칸 더 이동한 것이다. (2, 4)에는 상어 2과 4가 같이 도달했기 때문에, 상어 4는 격자 밖으로 쫓겨났다. <그림 4> <그림 5> <그림 4>은 격자에 남아있는 모든 상어가 한 칸 이동하고 자신의 냄새를 뿌린 상태, <그림 5>는 <그림 4>에서 한 칸 더 이동한 상태를 나타낸다. 상어 2는 인접한 칸 중에 아무 냄새도 없는 칸이 없으므로 자신의 냄새가 들어있는 (2, 4)으로 이동했다. 상어가 이동한 후에, 맨 처음에 각 상어가 뿌린 냄새는 사라졌다. 이 과정을 반복할 때, 1번 상어만 격자에 남게 되기까지 몇 초가 걸리는지를 구하는 프로그램을 작성하시오.",0
32,스타트 택시,"스타트링크가 ""스타트 택시""라는 이름의 택시 사업을 시작했다. 스타트 택시는 특이하게도 손님을 도착지로 데려다줄 때마다 연료가 충전되고, 연료가 바닥나면 그 날의 업무가 끝난다. 택시 기사 최백준은 오늘 M명의 승객을 태우는 것이 목표이다. 백준이 활동할 영역은 N×N 크기의 격자로 나타낼 수 있고, 각 칸은 비어 있거나 벽이 놓여 있다. 택시가 빈칸에 있을 때, 상하좌우로 인접한 빈칸 중 하나로 이동할 수 있다. 알고리즘 경력이 많은 백준은 특정 위치로 이동할 때 항상 최단경로로만 이동한다. M명의 승객은 빈칸 중 하나에 서 있으며, 다른 빈칸 중 하나로 이동하려고 한다. 여러 승객이 같이 탑승하는 경우는 없다. 따라서 백준은 한 승객을 태워 목적지로 이동시키는 일을 M번 반복해야 한다. 각 승객은 스스로 움직이지 않으며, 출발지에서만 택시에 탈 수 있고, 목적지에서만 택시에서 내릴 수 있다. 백준이 태울 승객을 고를 때는 현재 위치에서 최단거리가 가장 짧은 승객을 고른다. 그런 승객이 여러 명이면 그중 행 번호가 가장 작은 승객을, 그런 승객도 여러 명이면 그중 열 번호가 가장 작은 승객을 고른다. 택시와 승객이 같은 위치에 서 있으면 그 승객까지의 최단거리는 0이다. 연료는 한 칸 이동할 때마다 1만큼 소모된다. 한 승객을 목적지로 성공적으로 이동시키면, 그 승객을 태워 이동하면서 소모한 연료 양의 두 배가 충전된다. 이동하는 도중에 연료가 바닥나면 이동에 실패하고, 그 날의 업무가 끝난다. 승객을 목적지로 이동시킨 동시에 연료가 바닥나는 경우는 실패한 것으로 간주하지 않는다. <그림 1> <그림 1>은 택시가 활동할 영역의 지도를 나타내며, 택시와 세 명의 승객의 출발지와 목적지가 표시되어 있다. 택시의 현재 연료 양은 15이다. 현재 택시에서 각 손님까지의 최단거리는 각각 9, 6, 7이므로, 택시는 2번 승객의 출발지로 이동한다. <그림 2> <그림 3> <그림 2>는 택시가 2번 승객의 출발지로 가는 경로를, <그림 3>은 2번 승객의 출발지에서 목적지로 가는 경로를 나타낸다. 목적지로 이동할 때까지 소비한 연료는 6이고, 이동하고 나서 12가 충전되므로 남은 연료의 양은 15이다. 이제 택시에서 각 손님까지의 최단거리는 둘 다 7이므로, 택시는 둘 중 행 번호가 더 작은 1번 승객의 출발지로 이동한다. <그림 4> <그림 5> <그림 4>와 <그림 5>는 택시가 1번 승객을 태워 목적지로 이동시키는 경로를 나타낸다. 남은 연료의 양은 15 - 7 - 7 + 7×2 = 15이다. <그림 6> <그림 7> <그림 6>과 <그림 7>은 택시가 3번 승객을 태워 목적지로 이동시키는 경로를 나타낸다. 최종적으로 남은 연료의 양은 15 - 5 - 4 + 4×2 = 14이다. 모든 승객을 성공적으로 데려다줄 수 있는지 알아내고, 데려다줄 수 있을 경우 최종적으로 남는 연료의 양을 출력하는 프로그램을 작성하시오.",0
33,컨베이어 벨트 위의 로봇,"길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다. 벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 Ai이다. 위의 그림에서 1번 칸이 있는 위치를 ""올리는 위치"", N번 칸이 있는 위치를 ""내리는 위치""라고 한다. 컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다. 컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다. 가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다. 로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다. 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다. 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다. 종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다.",0
34,마법사 상어와 파이어볼,"어른 상어가 마법사가 되었고, 파이어볼을 배웠다. 마법사 상어가 크기가 N×N인 격자에 파이어볼 M개를 발사했다. 가장 처음에 파이어볼은 각자 위치에서 이동을 대기하고 있다. i번 파이어볼의 위치는 (ri, ci), 질량은 mi이고, 방향은 di, 속력은 si이다. 위치 (r, c)는 r행 c열을 의미한다. 격자의 행과 열은 1번부터 N번까지 번호가 매겨져 있고, 1번 행은 N번과 연결되어 있고, 1번 열은 N번 열과 연결되어 있다. 파이어볼의 방향은 어떤 칸과 인접한 8개의 칸의 방향을 의미하며, 정수로는 다음과 같다. 7 0 1 6 2 5 4 3 마법사 상어가 모든 파이어볼에게 이동을 명령하면 다음이 일들이 일어난다. 모든 파이어볼이 자신의 방향 di로 속력 si칸 만큼 이동한다. 이동하는 중에는 같은 칸에 여러 개의 파이어볼이 있을 수도 있다. 이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다. 같은 칸에 있는 파이어볼은 모두 하나로 합쳐진다. 파이어볼은 4개의 파이어볼로 나누어진다. 나누어진 파이어볼의 질량, 속력, 방향은 다음과 같다. 질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다. 속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋이다. 합쳐지는 파이어볼의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다. 질량이 0인 파이어볼은 소멸되어 없어진다. 마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 구해보자.",0
35,마법사 상어와 토네이도,"마법사 상어가 토네이도를 배웠고, 오늘은 토네이도를 크기가 N×N인 격자로 나누어진 모래밭에서 연습하려고 한다. 위치 (r, c)는 격자의 r행 c열을 의미하고, A[r][c]는 (r, c)에 있는 모래의 양을 의미한다. 토네이도를 시전하면 격자의 가운데 칸부터 토네이도의 이동이 시작된다. 토네이도는 한 번에 한 칸 이동한다. 다음은 N = 7인 경우 토네이도의 이동이다. 토네이도가 한 칸 이동할 때마다 모래는 다음과 같이 일정한 비율로 흩날리게 된다. 토네이도가 x에서 y로 이동하면, y의 모든 모래가 비율과 α가 적혀있는 칸으로 이동한다. 비율이 적혀있는 칸으로 이동하는 모래의 양은 y에 있는 모래의 해당 비율만큼이고, 계산에서 소수점 아래는 버린다. α로 이동하는 모래의 양은 비율이 적혀있는 칸으로 이동하지 않은 남은 모래의 양과 같다. 모래가 이미 있는 칸으로 모래가 이동하면, 모래의 양은 더해진다. 위의 그림은 토네이도가 왼쪽으로 이동할 때이고, 다른 방향으로 이동하는 경우는 위의 그림을 해당 방향으로 회전하면 된다. 토네이도는 (1, 1)까지 이동한 뒤 소멸한다. 모래가 격자의 밖으로 이동할 수도 있다. 토네이도가 소멸되었을 때, 격자의 밖으로 나간 모래의 양을 구해보자.",0
36,마법사 상어와 파이어스톰,"마법사 상어는 파이어볼과 토네이도를 조합해 파이어스톰을 시전할 수 있다. 오늘은 파이어스톰을 크기가 2N × 2N인 격자로 나누어진 얼음판에서 연습하려고 한다. 위치 (r, c)는 격자의 r행 c열을 의미하고, A[r][c]는 (r, c)에 있는 얼음의 양을 의미한다. A[r][c]가 0인 경우 얼음이 없는 것이다. 파이어스톰을 시전하려면 시전할 때마다 단계 L을 결정해야 한다. 파이어스톰은 먼저 격자를 2L × 2L 크기의 부분 격자로 나눈다. 그 후, 모든 부분 격자를 시계 방향으로 90도 회전시킨다. 이후 얼음이 있는 칸 3개 또는 그 이상과 인접해있지 않은 칸은 얼음의 양이 1 줄어든다. (r, c)와 인접한 칸은 (r-1, c), (r+1, c), (r, c-1), (r, c+1)이다. 아래 그림의 칸에 적힌 정수는 칸을 구분하기 위해 적은 정수이다. 마법을 시전하기 전 L = 1 L = 2 마법사 상어는 파이어스톰을 총 Q번 시전하려고 한다. 모든 파이어스톰을 시전한 후, 다음 2가지를 구해보자. 남아있는 얼음 A[r][c]의 합 남아있는 얼음 중 가장 큰 덩어리가 차지하는 칸의 개수 얼음이 있는 칸이 얼음이 있는 칸과 인접해 있으면, 두 칸을 연결되어 있다고 한다. 덩어리는 연결된 칸의 집합이다.",0
37,상어 초등학교,"상어 초등학교에는 교실이 하나 있고, 교실은 N×N 크기의 격자로 나타낼 수 있다. 학교에 다니는 학생의 수는 N2명이다. 오늘은 모든 학생의 자리를 정하는 날이다. 학생은 1번부터 N2번까지 번호가 매겨져 있고, (r, c)는 r행 c열을 의미한다. 교실의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다. 선생님은 학생의 순서를 정했고, 각 학생이 좋아하는 학생 4명도 모두 조사했다. 이제 다음과 같은 규칙을 이용해 정해진 순서대로 학생의 자리를 정하려고 한다. 한 칸에는 학생 한 명의 자리만 있을 수 있고, |r1 - r2| + |c1 - c2| = 1을 만족하는 두 칸이 (r1, c1)과 (r2, c2)를 인접하다고 한다. 비어있는 칸 중에서 좋아하는 학생이 인접한 칸에 가장 많은 칸으로 자리를 정한다. 1을 만족하는 칸이 여러 개이면, 인접한 칸 중에서 비어있는 칸이 가장 많은 칸으로 자리를 정한다. 2를 만족하는 칸도 여러 개인 경우에는 행의 번호가 가장 작은 칸으로, 그러한 칸도 여러 개이면 열의 번호가 가장 작은 칸으로 자리를 정한다. 예를 들어, N = 3이고, 학생 N2명의 순서와 각 학생이 좋아하는 학생이 다음과 같은 경우를 생각해보자. 학생의 번호 좋아하는 학생의 번호 4 2, 5, 1, 7 3 1, 9, 4, 5 9 8, 1, 2, 3 8 1, 9, 3, 4 7 2, 3, 4, 8 1 9, 2, 5, 7 6 5, 2, 3, 4 5 1, 9, 2, 8 2 9, 3, 1, 4 가장 먼저, 4번 학생의 자리를 정해야 한다. 현재 교실의 모든 칸은 빈 칸이다. 2번 조건에 의해 인접한 칸 중에서 비어있는 칸이 가장 많은 칸인 (2, 2)이 4번 학생의 자리가 된다. 4 다음 학생은 3번이다. 1번 조건을 만족하는 칸은 (1, 2), (2, 1), (2, 3), (3, 2) 이다. 이 칸은 모두 비어있는 인접한 칸이 2개이다. 따라서, 3번 조건에 의해 (1, 2)가 3번 학생의 자리가 된다. 3 4 다음은 9번 학생이다. 9번 학생이 좋아하는 학생의 번호는 8, 1, 2, 3이고, 이 중에 3은 자리에 앉아있다. 좋아하는 학생이 가장 많이 인접한 칸은 (1, 1), (1, 3)이다. 두 칸 모두 비어있는 인접한 칸이 1개이고, 행의 번호도 1이다. 따라서, 3번 조건에 의해 (1, 1)이 9번 학생의 자리가 된다. 9 3 4 이번에 자리를 정할 학생은 8번 학생이다. (2, 1)이 8번 학생이 좋아하는 학생과 가장 많이 인접한 칸이기 때문에, 여기가 그 학생의 자리이다. 9 3 8 4 7번 학생의 자리를 정해보자. 1번 조건을 만족하는 칸은 (1, 3), (2, 3), (3, 1), (3, 2)로 총 4개가 있고, 비어있는 칸과 가장 많이 인접한 칸은 (2, 3), (3, 2)이다. 행의 번호가 작은 (2, 3)이 7번 학생의 자리가 된다. 9 3 8 4 7 이런식으로 학생의 자리를 모두 정하면 다음과 같다. 9 3 2 8 4 7 5 6 1 이제 학생의 만족도를 구해야 한다. 학생의 만족도는 자리 배치가 모두 끝난 후에 구할 수 있다. 학생의 만족도를 구하려면 그 학생과 인접한 칸에 앉은 좋아하는 학생의 수를 구해야 한다. 그 값이 0이면 학생의 만족도는 0, 1이면 1, 2이면 10, 3이면 100, 4이면 1000이다. 학생의 만족도의 총 합을 구해보자.",0
38,상어 중학교,"상어 중학교의 코딩 동아리에서 게임을 만들었다. 이 게임은 크기가 N×N인 격자에서 진행되고, 초기에 격자의 모든 칸에는 블록이 하나씩 들어있고, 블록은 검은색 블록, 무지개 블록, 일반 블록이 있다. 일반 블록은 M가지 색상이 있고, 색은 M이하의 자연수로 표현한다. 검은색 블록은 -1, 무지개 블록은 0으로 표현한다. (i, j)는 격자의 i번 행, j번 열을 의미하고, |r1 - r2| + |c1 - c2| = 1을 만족하는 두 칸 (r1, c1)과 (r2, c2)를 인접한 칸이라고 한다. 블록 그룹은 연결된 블록의 집합이다. 그룹에는 일반 블록이 적어도 하나 있어야 하며, 일반 블록의 색은 모두 같아야 한다. 검은색 블록은 포함되면 안 되고, 무지개 블록은 얼마나 들어있든 상관없다. 그룹에 속한 블록의 개수는 2보다 크거나 같아야 하며, 임의의 한 블록에서 그룹에 속한 인접한 칸으로 이동해서 그룹에 속한 다른 모든 칸으로 이동할 수 있어야 한다. 블록 그룹의 기준 블록은 무지개 블록이 아닌 블록 중에서 행의 번호가 가장 작은 블록, 그러한 블록이 여러개면 열의 번호가 가장 작은 블록이다. 오늘은 이 게임에 오토 플레이 기능을 만드려고 한다. 오토 플레이는 다음과 같은 과정이 블록 그룹이 존재하는 동안 계속해서 반복되어야 한다. 크기가 가장 큰 블록 그룹을 찾는다. 그러한 블록 그룹이 여러 개라면 포함된 무지개 블록의 수가 가장 많은 블록 그룹, 그러한 블록도 여러개라면 기준 블록의 행이 가장 큰 것을, 그 것도 여러개이면 열이 가장 큰 것을 찾는다. 1에서 찾은 블록 그룹의 모든 블록을 제거한다. 블록 그룹에 포함된 블록의 수를 B라고 했을 때, B2점을 획득한다. 격자에 중력이 작용한다. 격자가 90도 반시계 방향으로 회전한다. 다시 격자에 중력이 작용한다. 격자에 중력이 작용하면 검은색 블록을 제외한 모든 블록이 행의 번호가 큰 칸으로 이동한다. 이동은 다른 블록이나 격자의 경계를 만나기 전까지 계속 된다. 다음은 N = 5, M = 3인 경우의 예시이다. 2 2 -1 3 1 3 3 2 0 -1 0 0 0 1 2 -1 3 1 3 2 0 3 2 2 1 여기서 찾을 수 있는 크기가 가장 큰 블록 그룹을 다음과 같이 빨간색으로 표시했다. 2 2 -1 3 1 3 3 2 0 -1 0 0 0 1 2 -1 3 1 3 2 0 3 2 2 1 블록 그룹이 제거되면 다음과 같이 변하고, 점수 82점을 획득한다. 2 2 -1 3 1 2 0 -1 1 2 -1 1 3 2 2 2 1 중력이 작용하면 다음과 같이 변한다. -1 3 1 0 -1 2 2 1 2 -1 1 3 2 2 2 2 1 90도 반시계방향으로 회전한 결과는 다음과 같다. 1 -1 2 2 1 3 0 1 3 2 -1 2 1 2 2 2 -1 다시 여기서 중력이 작용하면 다음과 같이 변한다. 1 -1 3 2 2 1 -1 1 3 2 2 1 2 0 2 -1 2 오토 플레이가 모두 끝났을 때 획득한 점수의 합을 구해보자.",0
39,마법사 상어와 비바라기,"마법사 상어는 파이어볼, 토네이도, 파이어스톰, 물복사버그 마법을 할 수 있다. 오늘 새로 배운 마법은 비바라기이다. 비바라기를 시전하면 하늘에 비구름을 만들 수 있다. 오늘은 비바라기를 크기가 N×N인 격자에서 연습하려고 한다. 격자의 각 칸에는 바구니가 하나 있고, 바구니는 칸 전체를 차지한다. 바구니에 저장할 수 있는 물의 양에는 제한이 없다. (r, c)는 격자의 r행 c열에 있는 바구니를 의미하고, A[r][c]는 (r, c)에 있는 바구니에 저장되어 있는 물의 양을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다. 마법사 상어는 연습을 위해 1번 행과 N번 행을 연결했고, 1번 열과 N번 열도 연결했다. 즉, N번 행의 아래에는 1번 행이, 1번 행의 위에는 N번 행이 있고, 1번 열의 왼쪽에는 N번 열이, N번 열의 오른쪽에는 1번 열이 있다. 비바라기를 시전하면 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 비구름이 생긴다. 구름은 칸 전체를 차지한다. 이제 구름에 이동을 M번 명령하려고 한다. i번째 이동 명령은 방향 di과 거리 si로 이루어져 있다. 방향은 총 8개의 방향이 있으며, 8개의 정수로 표현한다. 1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙ 이다. 이동을 명령하면 다음이 순서대로 진행된다. 모든 구름이 di 방향으로 si칸 이동한다. 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다. 구름이 모두 사라진다. 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다. 이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다. 예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다. 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다. M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구해보자.",0
40,마법사 상어와 블리자드,"마법사 상어는 파이어볼, 토네이도, 파이어스톰, 물복사버그, 비바라기 마법을 할 수 있다. 오늘 새로 배운 마법은 블리자드이고, 크기가 N×N인 격자에서 연습하려고 한다. N은 항상 홀수이고, (r, c)는 격자의 r행 c열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이며 마법사 상어는 ((N+1)/2, (N+1)/2)에 있다. 일부 칸과 칸 사이에는 벽이 세워져 있으며, 다음은 N = 3, 5, 7인 경우의 예시이다. 실선은 벽이고, 점선은 벽이 아니다. 칸에 적혀있는 수는 칸의 번호이다. N = 3 N = 5 N = 7 가장 처음에 상어가 있는 칸을 제외한 나머지 칸에는 구슬이 하나 들어갈 수 있다. 구슬은 1번 구슬, 2번 구슬, 3번 구슬이 있다. 같은 번호를 가진 구슬이 번호가 연속하는 칸에 있으면, 그 구슬을 연속하는 구슬이라고 한다. 다음은 N = 7인 경우 예시이다. 블리자드 마법을 시전하려면 방향 di와 거리 si를 정해야 한다. 총 4가지 방향 ↑, ↓, ←, →가 있고, 정수 1, 2, 3, 4로 나타낸다. 상어는 di 방향으로 거리가 si 이하인 모든 칸에 얼음 파편을 던져 그 칸에 있는 구슬을 모두 파괴한다. 구슬이 파괴되면 그 칸은 구슬이 들어있지 않은 빈 칸이 된다. 얼음 파편은 벽의 위로 떨어지기 때문에, 벽은 파괴되지 않는다. 다음 예시는 방향은 아래, 거리는 2인 경우이다. 빨간색으로 표시된 칸에 얼음 파편이 떨어진다. 구슬이 파괴된 후 만약 어떤 칸 A의 번호보다 번호가 하나 작은 칸이 빈 칸이면, A에 있는 구슬은 그 빈 칸으로 이동한다. 이 이동은 더 이상 구슬이 이동하지 않을 때까지 반복된다. 따라서, 구슬이 파괴된 후에는 빈 칸이 생겨 구슬이 이동하고, 구슬이 모두 이동한 결과는 다음과 같다. 이제 구슬이 폭발하는 단계이다. 폭발하는 구슬은 4개 이상 연속하는 구슬이 있을 때 발생한다. 다음은 왼쪽 그림은 위의 상태에서 폭발하는 구슬이 들어있는 칸을 파란색과 초록색으로 표시한 것이고, 오른쪽 그림은 구슬이 폭발한 후의 상태이다. 구슬이 폭발하기 전 구슬이 폭발한 후 구슬이 폭발해 빈 칸이 생겼으니 다시 구슬이 이동한다. 구슬이 이동한 후에는 다시 구슬이 폭발하는 단계이고, 이 과정은 더 이상 폭발하는 구슬이 없을때까지 반복된다. 구슬이 폭발한 후의 상태에서 구슬이 이동하면 다음과 같다. 위의 상태는 4개 이상 연속하는 구슬이 있기 때문에 구슬이 다시 폭발하게 된다. 구슬이 폭발하기 전 구슬이 폭발하고 이동한 후 이제 더 이상 폭발한 구슬이 없기 때문에, 구슬이 변화하는 단계가 된다. 연속하는 구슬은 하나의 그룹이라고 한다. 다음은 1번 구슬은 빨간색, 2번 구슬은 파란색, 3번 구슬은 보라색으로 표시한 그림이다. 하나의 그룹은 두 개의 구슬 A와 B로 변한다. 구슬 A의 번호는 그룹에 들어있는 구슬의 개수이고, B는 그룹을 이루고 있는 구슬의 번호이다. 구슬은 다시 그룹의 순서대로 1번 칸부터 차례대로 A, B의 순서로 칸에 들어간다. 다음 그림은 구슬이 변화한 후이고, 색은 구분하기 위해 위의 그림에 있는 그룹의 색을 그대로 사용했다. 만약, 구슬이 칸의 수보다 많아 칸에 들어가지 못하는 경우 그러한 구슬은 사라진다. 마법사 상어는 블리자드를 총 M번 시전했다. 시전한 마법의 정보가 주어졌을 때, 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)를 구해보자.",0
41,주사위 굴리기 2,"크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 가장 왼쪽 위에 있는 칸의 좌표는 (1, 1)이고, 가장 오른쪽 아래에 있는 칸의 좌표는 (N, M)이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 각 면에는 1보다 크거나 같고, 6보다 작거나 같은 정수가 하나씩 있다. 주사위 한 면의 크기와 지도 한 칸의 크기는 같고, 주사위의 전개도는 아래와 같다. 2 4 1 3 5 6 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (1, 1) 이다. 지도의 각 칸에도 정수가 하나씩 있다. 가장 처음에 주사위의 이동 방향은 동쪽이다. 주사위의 이동 한 번은 다음과 같은 방식으로 이루어진다. 주사위가 이동 방향으로 한 칸 굴러간다. 만약, 이동 방향에 칸이 없다면, 이동 방향을 반대로 한 다음 한 칸 굴러간다. 주사위가 도착한 칸 (x, y)에 대한 점수를 획득한다. 주사위의 아랫면에 있는 정수 A와 주사위가 있는 칸 (x, y)에 있는 정수 B를 비교해 이동 방향을 결정한다. A > B인 경우 이동 방향을 90도 시계 방향으로 회전시킨다. A < B인 경우 이동 방향을 90도 반시계 방향으로 회전시킨다. A = B인 경우 이동 방향에 변화는 없다. 칸 (x, y)에 대한 점수는 다음과 같이 구할 수 있다. (x, y)에 있는 정수를 B라고 했을때, (x, y)에서 동서남북 방향으로 연속해서 이동할 수 있는 칸의 수 C를 모두 구한다. 이때 이동할 수 있는 칸에는 모두 정수 B가 있어야 한다. 여기서 점수는 B와 C를 곱한 값이다. 보드의 크기와 각 칸에 있는 정수, 주사위의 이동 횟수 K가 주어졌을때, 각 이동에서 획득하는 점수의 합을 구해보자. 이 문제의 예제 1부터 7은 같은 지도에서 이동하는 횟수만 증가시키는 방식으로 구성되어 있다. 예제 8은 같은 지도에서 이동하는 횟수를 매우 크게 만들었다.",0
42,온풍기 안녕!,"유난히 추운 날씨가 예상되는 이번 겨울을 대비하기 위해 구사과는 온풍기를 설치하려고 한다. 온풍기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)의 온도를 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다. 구사과의 성능 테스트는 다음과 같은 작업이 순차적으로 이루어지며, 가장 처음에 모든 칸의 온도는 0이다. 문제의 그림에서 빈 칸은 온도가 0인 칸을 의미한다. 집에 있는 모든 온풍기에서 바람이 한 번 나옴 온도가 조절됨 온도가 1 이상인 가장 바깥쪽 칸의 온도가 1씩 감소 초콜릿을 하나 먹는다. 조사하는 모든 칸의 온도가 K 이상이 되었는지 검사. 모든 칸의 온도가 K이상이면 테스트를 중단하고, 아니면 1부터 다시 시작한다. 집에 있는 모든 온풍기에서 바람이 한 번 나오는 과정을 설명하면 다음과 같다. <그림 1> <그림 1>은 크기가 7×8인 집에 온풍기가 (3, 1)에 설치되어 있는 상황이다. 온풍기는 바람이 나오는 방향이 있는데, 그 방향은 오른쪽, 왼쪽, 위, 아래 중 하나이다. 온풍기에서 따뜻한 바람이 한 번 나오면, 다음과 같은 영역의 온도가 칸에 적힌 값만큼 증가하게 된다. 아래 그림은 오른쪽 방향으로 바람이 나온 예시이며, 온풍기에서 바람이 나오는 방향에 따라 <그림 2>를 회전시켜서 해당하는 방향으로 바람이 나왔을 때 증가하는 온도를 구할 수 있다. <그림 2> 온풍기에서 바람이 한 번 나왔을 때, 온풍기의 바람이 나오는 방향에 있는 칸은 항상 온도가 5도 올라간다. 그 다음 이 바람은 계속 다른 칸으로 이동해 다른 칸의 온도를 위의 그림과 같이 상승시키게 된다. 어떤 칸 (x, y)에 온풍기 바람이 도착해 온도가 k (> 1)만큼 상승했다면, (x-1, y+1), (x, y+1), (x+1, y+1)의 온도도 k-1만큼 상승하게 된다. 이때 그 칸이 존재하지 않는다면, 바람은 이동하지 않는다. 온풍기에서 바람이 한 번 나왔을 때, 어떤 칸에 같은 온풍기에서 나온 바람이 여러 번 도착한다고 해도 온도는 여러번 상승하지 않는다. <그림 1>의 상태에서 온풍기 바람이 한 번 불었다면, 증가하는 온도의 양은 <그림 3>과 같다. <그림 3> 일부 칸과 칸 사이에는 벽이 있어 온풍기 바람이 지나갈 수 없다. 바람이 오른쪽으로 불었을 때 어떤 칸 (x, y)에서 (x-1, y+1)로 바람이 이동할 수 있으려면, (x, y)와 (x-1, y) 사이에 벽이 없어야 하고, (x-1, y)와 (x-1, y+1) 사이에도 벽이 없어야 한다. (x, y)에서 (x, y+1)로 바람이 이동할 수 있으려면 (x, y)와 (x, y+1) 사이에 벽이 없어야 한다. 마지막으로 (x, y)에서 (x+1, y+1)로 바람이 이동할 수 있으려면, (x, y)와 (x+1, y), (x+1, y)와 (x+1, y+1) 사이에 벽이 없어야 한다. 예를 들어, (3, 4)와 (3, 5) 사이에 벽이 있는 경우 온풍기에서 바람이 한 번 나왔을 때 온도는 <그림 4>와 같이 상승한다. 벽은 빨간색으로 표시했다. <그림 4> (3, 5)는 (3, 4), (2, 4), (4, 4)에서 바람이 이동할 수 없기 때문에, 온도가 상승하지 않는다. 만약 바람의 방향이 왼쪽인 온풍기가 (4, 7)에 있고, (3, 4)와 (3, 5) 사이에 벽, (2, 5)와 (3, 5) 사이에 벽이 있는 경우라면 온풍기에서 바람이 한 번 나왔을 때 <그림 5>와 같이 온도가 상승한다. <그림 6>은 바람의 방향이 아래인 온풍기가 (2, 5)에 있고, (4, 4)와 (4, 5) 사이, (4, 4)와 (5, 4) 사이, (4, 6)과 (5, 6) 사이에 벽이 있는 경우이다. <그림 5> <그림 6> 구사과의 집에는 온풍기가 2대 이상 있을 수도 있다. 이 경우 각각의 온풍기에 의해서 상승한 온도를 모두 합한 값이 해당 칸의 상승한 온도이다. 예를 들어, <그림 7>은 <그림 6>과 같은 벽을 가지고 있는 집에서 바람이 방향이 위인 온풍기가 (7, 5)에 있는 경우이고, <그림 8>는 <그림 6>과 같은 벽을 가지고 있는 집에서 바람의 방향이 아래인 온풍기가 (2, 5)에 있고, 바람의 방향이 위인 온풍기가 (7, 5)에 있는 경우이다. <그림 8>는 같은 벽을 가지고 있는 집에서 <그림 6>의 온풍기와 <그림 7>의 온풍기가 동시에 설치된 상황이기 때문에, 각 칸의 상승한 온도는 두 그림의 값을 더한 값과 같다. 온풍기가 있는 칸도 다른 온풍기에 의해 온도가 상승할 수 있기 때문에, <그림 8>에서 온풍기의 위치는 표시하지 않았다. <그림 7> <그림 8> 온도가 조절되는 과정은 다음과 같다. 모든 인접한 칸에 대해서, 온도가 높은 칸에서 낮은 칸으로 ⌊(두 칸의 온도의 차이)/4⌋만큼 온도가 조절된다. 온도가 높은 칸은 이 값만큼 온도가 감소하고, 낮은 칸은 온도가 상승한다. 인접한 두 칸 사이에 벽이 있는 경우에는 온도가 조절되지 않는다. 이 과정은 모든 칸에 대해서 동시에 발생한다. 다음은 온도 조절의 예시이다. (1, 1)에서 (1, 2)와 (1, 3)으로 공기가 섞인다. (2, 2)와 (3, 2) 사이에 벽이 있기 때문에, (3, 2)는 온도가 그대로 유지된다. 모든 칸에 대해서 동시에 온도의 조절이 발생한다. 가장 바깥쪽 칸은 1행, R행, 1열, C열에 있는 칸이다. 예를 들어, <그림 9>와 같은 경우 가장 바깥쪽 칸의 온도가 1씩 감소하면 <그림 10>과 같이 된다. 온도가 0인 칸은 온도가 감소하지 않는다. <그림 9> <그림 10> 방의 크기와 방에 설치된 온풍기의 정보, 벽의 위치와 조사하려고 하는 칸의 위치가 주어진다. 구사과가 먹은 초콜릿의 개수를 출력한다.",0
43,마법사 상어와 복제,"마법사 상어는 파이어볼, 토네이도, 파이어스톰, 물복사버그, 비바라기, 블리자드 마법을 할 수 있다. 오늘은 기존에 배운 물복사버그 마법의 상위 마법인 복제를 배웠고, 4 × 4 크기의 격자에서 연습하려고 한다. (r, c)는 격자의 r행 c열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (4, 4)이다. 격자에는 물고기 M마리가 있다. 각 물고기는 격자의 칸 하나에 들어가 있으며, 이동 방향을 가지고 있다. 이동 방향은 8가지 방향(상하좌우, 대각선) 중 하나이다. 마법사 상어도 연습을 위해 격자에 들어가있다. 상어도 격자의 한 칸에 들어가있다. 둘 이상의 물고기가 같은 칸에 있을 수도 있으며, 마법사 상어와 물고기가 같은 칸에 있을 수도 있다. 상어의 마법 연습 한 번은 다음과 같은 작업이 순차적으로 이루어진다. 상어가 모든 물고기에게 복제 마법을 시전한다. 복제 마법은 시간이 조금 걸리기 때문에, 아래 5번에서 물고기가 복제되어 칸에 나타난다. 모든 물고기가 한 칸 이동한다. 상어가 있는 칸, 물고기의 냄새가 있는 칸, 격자의 범위를 벗어나는 칸으로는 이동할 수 없다. 각 물고기는 자신이 가지고 있는 이동 방향이 이동할 수 있는 칸을 향할 때까지 방향을 45도 반시계 회전시킨다. 만약, 이동할 수 있는 칸이 없으면 이동을 하지 않는다. 그 외의 경우에는 그 칸으로 이동을 한다. 물고기의 냄새는 아래 3에서 설명한다. 상어가 연속해서 3칸 이동한다. 상어는 현재 칸에서 상하좌우로 인접한 칸으로 이동할 수 있다. 연속해서 이동하는 칸 중에 격자의 범위를 벗어나는 칸이 있으면, 그 방법은 불가능한 이동 방법이다. 연속해서 이동하는 중에 상어가 물고기가 있는 같은 칸으로 이동하게 된다면, 그 칸에 있는 모든 물고기는 격자에서 제외되며, 제외되는 모든 물고기는 물고기 냄새를 남긴다. 가능한 이동 방법 중에서 제외되는 물고기의 수가 가장 많은 방법으로 이동하며, 그러한 방법이 여러가지인 경우 사전 순으로 가장 앞서는 방법을 이용한다. 사전 순에 대한 문제의 하단 노트에 있다. 두 번 전 연습에서 생긴 물고기의 냄새가 격자에서 사라진다. 1에서 사용한 복제 마법이 완료된다. 모든 복제된 물고기는 1에서의 위치와 방향을 그대로 갖게 된다. 격자에 있는 물고기의 위치, 방향 정보와 상어의 위치, 그리고 연습 횟수 S가 주어진다. S번 연습을 모두 마쳤을때, 격자에 있는 물고기의 수를 구해보자.",0
44,어항 정리,"마법사 상어는 그동안 배운 마법을 이용해 어항을 정리하려고 한다. 어항은 정육면체 모양이고, 한 변의 길이는 모두 1이다. 상어가 가지고 있는 어항은 N개이고, 가장 처음에 어항은 일렬로 바닥 위에 놓여져 있다. 어항에는 물고기가 한 마리 이상 들어있다. <그림 1>은 어항 8개가 바닥 위에 놓여있는 상태이며, 칸에 적힌 값은 그 어항에 들어있는 물고기의 수이다. 편의상 어항은 정사각형으로 표현했다. <그림 1> 어항을 한 번 정리하는 과정은 다음과 같이 이루어져 있다. 먼저, 물고기의 수가 가장 적은 어항에 물고기를 한 마리 넣는다. 만약, 그러한 어항이 여러개라면 물고기의 수가 최소인 어항 모두에 한 마리씩 넣는다. 위의 예시의 경우 물고기의 수가 가장 적은 어항에는 물고기가 2마리 있고, 그러한 어항은 2개가 있다. 따라서, 2개의 어항에 물고기를 한 마리씩 넣어 <그림 2>와 같아진다. <그림 2> 이제 어항을 쌓는다. 먼저, 가장 왼쪽에 있는 어항을 그 어항의 오른쪽에 있는 어항의 위에 올려 놓아 <그림 3>이 된다. <그림 3> 이제, 2개 이상 쌓여있는 어항을 모두 공중 부양시킨 다음, 전체를 시계방향으로 90도 회전시킨다. 이후 공중 부양시킨 어항을 바닥에 있는 어항의 위에 올려놓는다. 바닥의 가장 왼쪽에 있는 어항 위에 공중 부양시킨 어항 중 가장 왼쪽에 있는 어항이 있어야 한다. 이 작업은 공중 부양시킨 어항 중 가장 오른쪽에 있는 어항의 아래에 바닥에 있는 어항이 있을때까지 반복한다. 먼저, <그림 4>와 같이 어항이 놓인 상태가 변하고, 한 번 더 변해서 <그림 5>가 된다. <그림 4> <그림 5> <그림 5>에서 한 번 더 어항을 공중 부양시키는 것은 불가능하다. 그 이유는 <그림 6>과 같이 공중 부양시킨 어항 중 가장 오른쪽에 있는 어항의 아래에 바닥에 있는 어항이 없기 때문이다. <그림 6> 공중 부양 작업이 모두 끝나면, 어항에 있는 물고기의 수를 조절한다. 모든 인접한 두 어항에 대해서, 물고기 수의 차이를 구한다. 이 차이를 5로 나눈 몫을 d라고 하자. d가 0보다 크면, 두 어항 중 물고기의 수가 많은 곳에 있는 물고기 d 마리를 적은 곳에 있는 곳으로 보낸다. 이 과정은 모든 인접한 칸에 대해서 동시에 발생한다. 이 과정이 완료되면 <그림 7>이 된다. <그림 7> 이제 다시 어항을 바닥에 일렬로 놓아야 한다. 가장 왼쪽에 있는 어항부터, 그리고 아래에 있는 어항부터 가장 위에 있는 어항까지 순서대로 바닥에 놓아야 한다. <그림 8>이 바닥에 다시 일렬로 놓은 상태이다. <그림 8> 다시 공중 부양 작업을 해야 한다. 이번에는 가운데를 중심으로 왼쪽 N/2개를 공중 부양시켜 전체를 시계 방향으로 180도 회전 시킨 다음, 오른쪽 N/2개의 위에 놓아야 한다. 이 작업은 두 번 반복해야한다. 두 번 반복하면 바닥에 있는 어항의 수는 N/4개가 된다. <그림 9>는 이 작업을 1번 했을 때, <그림 10>은 다시 한 번 더 했을 때이다. <그림 9> <그림 10> 여기서 다시 위에서 한 물고기 조절 작업을 수행하고, 바닥에 일렬로 놓는 작업을 수행한다. <그림 10>에서 조절 작업을 마친 결과는 <그림 11>이 되고, 여기서 다시 바닥에 일렬로 놓는 작업을 수행하면 <그림 12>가 된다. <그림 11> <그림 12> 어항의 수 N, 각 어항에 들어있는 물고기의 수가 주어진다. 물고기가 가장 많이 들어있는 어항과 가장 적게 들어있는 어항의 물고기 수 차이가 K 이하가 되려면 어항을 몇 번 정리해야하는지 구해보자.",0
45,개인정보 수집 유효기간,"고객의 약관 동의를 얻어서 수집된 1~n번으로 분류되는 개인정보n개가 있습니다. 약관 종류는 여러 가지 있으며 각 약관마다 개인정보 보관 유효기간이 정해져 있습니다. 당신은 각 개인정보가 어떤 약관으로 수집됐는지 알고 있습니다. 수집된 개인정보는 유효기간 전까지만 보관 가능하며, 유효기간이 지났다면 반드시 파기해야 합니다.예를 들어, A라는 약관의 유효기간이 12 달이고, 2021년 1월 5일에 수집된 개인정보가 A약관으로 수집되었다면 해당 개인정보는 2022년 1월 4일까지 보관 가능하며 2022년 1월 5일부터 파기해야 할 개인정보입니다.당신은 오늘 날짜로 파기해야 할 개인정보 번호들을 구하려 합니다.모든 달은 28일까지 있다고 가정합니다.다음은 오늘 날짜가2022.05.19일 때의 예시입니다.약관 종류유효기간A6 달B12 달C3 달번호개인정보 수집 일자약관 종류12021.05.02A22021.07.01B32022.02.19C42022.02.20C첫 번째 개인정보는 A약관에 의해 2021년 11월 1일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.두 번째 개인정보는 B약관에 의해 2022년 6월 28일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.세 번째 개인정보는 C약관에 의해 2022년 5월 18일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.네 번째 개인정보는 C약관에 의해 2022년 5월 19일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.따라서 파기해야 할 개인정보 번호는 [1, 3]입니다.오늘 날짜를 의미하는 문자열today, 약관의 유효기간을 담은 1차원 문자열 배열terms와 수집된 개인정보의 정보를 담은 1차원 문자열 배열privacies가 매개변수로 주어집니다. 이때 파기해야 할 개인정보의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.제한사항today는 ""YYYY.MM.DD"" 형태로 오늘 날짜를 나타냅니다.1 ≤terms의 길이 ≤ 20terms의 원소는 ""약관 종류유효기간"" 형태의약관 종류와유효기간을 공백 하나로 구분한 문자열입니다.약관 종류는A~Z중 알파벳 대문자 하나이며,terms배열에서약관 종류는 중복되지 않습니다.유효기간은 개인정보를 보관할 수 있는 달 수를 나타내는 정수이며, 1 이상 100 이하입니다.1 ≤privacies의 길이 ≤ 100privacies[i]는i+1번 개인정보의 수집 일자와 약관 종류를 나타냅니다.privacies의 원소는 ""날짜약관 종류"" 형태의날짜와약관 종류를 공백 하나로 구분한 문자열입니다.날짜는 ""YYYY.MM.DD"" 형태의 개인정보가 수집된 날짜를 나타내며,today이전의 날짜만 주어집니다.privacies의약관 종류는 항상terms에 나타난약관 종류만 주어집니다.today와privacies에 등장하는날짜의YYYY는 연도,MM은 월,DD는 일을 나타내며 점(.) 하나로 구분되어 있습니다.2000 ≤YYYY≤ 20221 ≤MM≤ 12MM이 한 자릿수인 경우 앞에 0이 붙습니다.1 ≤DD≤ 28DD가 한 자릿수인 경우 앞에 0이 붙습니다.파기해야 할 개인정보가 하나 이상 존재하는 입력만 주어집니다.입출력 예todaytermsprivaciesresult""2022.05.19""[""A 6"", ""B 12"", ""C 3""][""2021.05.02 A"", ""2021.07.01 B"", ""2022.02.19 C"", ""2022.02.20 C""][1, 3]""2020.01.01""[""Z 3"", ""D 5""][""2019.01.01 D"", ""2019.11.15 Z"", ""2019.08.02 D"", ""2019.07.01 D"", ""2018.12.28 Z""][1, 4, 5]입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2약관 종류유효기간Z3 달D5 달번호개인정보 수집 일자약관 종류12019.01.01D22019.11.15Z32019.08.02D42019.07.01D52018.12.28Z오늘 날짜는 2020년 1월 1일입니다.첫 번째 개인정보는 D약관에 의해 2019년 5월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.두 번째 개인정보는 Z약관에 의해 2020년 2월 14일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.세 번째 개인정보는 D약관에 의해 2020년 1월 1일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.네 번째 개인정보는 D약관에 의해 2019년 11월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.다섯 번째 개인정보는 Z약관에 의해 2019년 3월 27일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.",1
46,택배 배달과 수거하기,"당신은 일렬로 나열된n개의 집에 택배를 배달하려 합니다. 배달할 물건은 모두 크기가 같은 재활용 택배 상자에 담아 배달하며, 배달을 다니면서 빈 재활용 택배 상자들을 수거하려 합니다.배달할 택배들은 모두 재활용 택배 상자에 담겨서 물류창고에 보관되어 있고,i번째 집은 물류창고에서 거리i만큼 떨어져 있습니다. 또한i번째 집은j번째 집과 거리j - i만큼 떨어져 있습니다. (1 ≤i≤j≤n)트럭에는 재활용 택배 상자를 최대cap개 실을 수 있습니다. 트럭은 배달할 재활용 택배 상자들을 실어 물류창고에서 출발해 각 집에 배달하면서, 빈 재활용 택배 상자들을 수거해 물류창고에 내립니다. 각 집마다 배달할 재활용 택배 상자의 개수와 수거할 빈 재활용 택배 상자의 개수를 알고 있을 때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 구하려 합니다.각 집에 배달 및 수거할 때, 원하는 개수만큼 택배를 배달 및 수거할 수 있습니다.다음은cap=4 일 때, 최소 거리로 이동하면서 5개의 집에 배달 및 수거하는 과정을 나타낸 예시입니다.배달 및 수거할 재활용 택배 상자 개수집 #1집 #2집 #3집 #4집 #5배달1개0개3개1개2개수거0개3개0개4개0개배달 및 수거 과정집 #1집 #2집 #3집 #4집 #5설명남은 배달/수거1/00/33/01/42/0물류창고에서 택배 3개를 트럭에 실어 출발합니다.남은 배달/수거1/00/33/00/40/0물류창고에서 5번째 집까지 이동하면서(거리 5) 4번째 집에 택배 1개를 배달하고, 5번째 집에 택배 2개를 배달합니다.남은 배달/수거1/00/33/00/00/05번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 4개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 4개를 트럭에 싣습니다.남은 배달/수거0/00/30/00/00/0물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 3개를 배달합니다.남은 배달/수거0/00/00/00/00/03번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 3개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다.16(=5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다.트럭에 실을 수 있는 재활용 택배 상자의 최대 개수를 나타내는 정수cap, 배달할 집의 개수를 나타내는 정수n, 각 집에 배달할 재활용 택배 상자의 개수를 담은 1차원 정수 배열deliveries와 각 집에서 수거할 빈 재활용 택배 상자의 개수를 담은 1차원 정수 배열pickups가 매개변수로 주어집니다. 이때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 return 하도록 solution 함수를 완성해 주세요.제한사항1 ≤cap≤ 501 ≤n≤ 100,000deliveries의 길이 =pickups의 길이 =ndeliveries[i]는 i+1번째 집에 배달할 재활용 택배 상자의 개수를 나타냅니다.pickups[i]는 i+1번째 집에서 수거할 빈 재활용 택배 상자의 개수를 나타냅니다.0 ≤deliveries의 원소 ≤ 500 ≤pickups의 원소 ≤ 50트럭의 초기 위치는 물류창고입니다.입출력 예capndeliveriespickupsresult45[1, 0, 3, 1, 2][0, 3, 0, 4, 0]1627[1, 0, 2, 0, 1, 0, 2][0, 2, 0, 1, 0, 2, 0]30입출력 예 설명입출력 예 #1문제 예시와 동일합니다.입출력 예 #2배달 및 수거할 재활용 택배 상자 개수집 #1집 #2집 #3집 #4집 #5집 #6집 #7배달1개0개2개0개1개0개2개수거0개2개0개1개0개2개0개배달 및 수거 과정집 #1집 #2집 #3집 #4집 #5집 #6집 #7설명남은 배달/수거1/00/22/00/11/00/22/0물류창고에서 택배 2개를 트럭에 실어 출발합니다.남은 배달/수거1/00/22/00/11/00/20/0물류창고에서 7번째 집까지 이동하면서(거리 7) 7번째 집에 택배 2개를 배달합니다.남은 배달/수거1/00/22/00/11/00/00/07번째 집에서 물류창고까지 이동하면서(거리 7) 6번째 집에서 빈 택배 상자 2개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 2개를 트럭에 싣습니다.남은 배달/수거1/00/21/00/10/00/00/0물류창고에서 5번째 집까지 이동하면서(거리 5) 3번째 집에 택배 1개를 배달하고, 5번째 집에 택배 1개를 배달합니다.남은 배달/수거1/00/11/00/00/00/00/05번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 1개를 수거하고 2번째 집에서 빈 택배 상자 1개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 2개를 트럭에 싣습니다.남은 배달/수거0/00/10/00/00/00/00/0물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 1개를 배달합니다.남은 배달/수거0/00/00/00/00/00/00/03번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 1개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다.30(=7+7+5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다.따라서, 30을 return 하면 됩니다.",1
47,이모티콘 할인행사,"카카오톡에서는 이모티콘을 무제한으로 사용할 수 있는 이모티콘 플러스 서비스 가입자 수를 늘리려고 합니다.이를 위해 카카오톡에서는 이모티콘 할인 행사를 하는데, 목표는 다음과 같습니다.이모티콘 플러스 서비스 가입자를 최대한 늘리는 것.이모티콘 판매액을 최대한 늘리는 것.1번 목표가 우선이며, 2번 목표가 그 다음입니다.이모티콘 할인 행사는 다음과 같은 방식으로 진행됩니다.n명의 카카오톡 사용자들에게 이모티콘m개를 할인하여 판매합니다.이모티콘마다 할인율은 다를 수 있으며, 할인율은 10%, 20%, 30%, 40% 중 하나로 설정됩니다.카카오톡 사용자들은 다음과 같은 기준을 따라 이모티콘을 사거나, 이모티콘 플러스 서비스에 가입합니다.각 사용자들은 자신의 기준에 따라 일정 비율 이상 할인하는 이모티콘을 모두 구매합니다.각 사용자들은 자신의 기준에 따라 이모티콘 구매 비용의 합이 일정 가격 이상이 된다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.다음은 2명의 카카오톡 사용자와 2개의 이모티콘이 있을때의 예시입니다.사용자비율가격14010,00022510,000이모티콘가격17,00029,0001번 사용자는 40%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.2번 사용자는 25%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.1번 이모티콘의 가격은 7,000원, 2번 이모티콘의 가격은 9,000원입니다.만약, 2개의 이모티콘을 모두 40%씩 할인한다면, 1번 사용자와 2번 사용자 모두 1,2번 이모티콘을 구매하게 되고, 결과는 다음과 같습니다.사용자구매한 이모티콘이모티콘 구매 비용이모티콘 플러스 서비스 가입 여부11, 29,600X21, 29,600X이모티콘 플러스 서비스 가입자는 0명이 늘어나고 이모티콘 판매액은 19,200원이 늘어납니다.하지만, 1번 이모티콘을 30% 할인하고 2번 이모티콘을 40% 할인한다면 결과는 다음과 같습니다.사용자구매한 이모티콘이모티콘 구매 비용이모티콘 플러스 서비스 가입 여부125,400X21, 210,300O2번 사용자는 이모티콘 구매 비용을 10,000원 이상 사용하여 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입하게 됩니다.따라서, 이모티콘 플러스 서비스 가입자는 1명이 늘어나고 이모티콘 판매액은 5,400원이 늘어나게 됩니다.카카오톡 사용자n명의 구매 기준을 담은 2차원 정수 배열users, 이모티콘m개의 정가를 담은 1차원 정수 배열emoticons가 주어집니다. 이때, 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항1 ≤users의 길이 =n≤ 100users의 원소는 [비율,가격]의 형태입니다.users[i]는i+1번 고객의 구매 기준을 의미합니다.비율% 이상의 할인이 있는 이모티콘을 모두 구매한다는 의미입니다.1 ≤비율≤ 40가격이상의 돈을 이모티콘 구매에 사용한다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입한다는 의미입니다.100 ≤가격≤ 1,000,000가격은 100의 배수입니다.1 ≤emoticons의 길이 =m≤ 7emoticons[i]는i+1번 이모티콘의 정가를 의미합니다.100 ≤emoticons의 원소 ≤ 1,000,000emoticons의 원소는 100의 배수입니다.입출력 예usersemoticonsresult[[40, 10000], [25, 10000]][7000, 9000][1, 5400][[40, 2900], [23, 10000], [11, 5200], [5, 5900], [40, 3100], [27, 9200], [32, 6900]][1300, 1500, 1600, 4900][4, 13860]입출력 예 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2다음과 같이 할인하는 것이 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법입니다.이모티콘할인율140240320440위와 같이 할인하면 4명의 이모티콘 플러스 가입자와 13,860원의 판매액을 달성할 수 있습니다. 다른 할인율을 적용하여 이모티콘을 판매할 수 있지만 이보다 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법은 없습니다.따라서, [4, 13860]을 return 하면 됩니다.",1
48,표현 가능한 이진트리,"당신은 이진트리를 수로 표현하는 것을 좋아합니다.이진트리를 수로 표현하는 방법은 다음과 같습니다.이진수를 저장할 빈 문자열을 생성합니다.주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다.루트 노드는 그대로 유지합니다.만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다.노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.문자열에 저장된 이진수를 십진수로 변환합니다.이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.다음은 이진트리를 수로 표현하는 예시입니다.주어진 이진트리는 다음과 같습니다.주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다.더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다.노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면""0111010""이 됩니다. 이 이진수를 십진수로 변환하면 58입니다.당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다.이진트리로 만들고 싶은 수를 담은 1차원 정수 배열numbers가 주어집니다.numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항1 ≤numbers의 길이 ≤ 10,0001 ≤numbers의 원소 ≤ 1015입출력 예numbersresult[7, 42, 5][1, 1, 0][63, 111, 95][1, 1, 0]입출력 예 설명입출력 예 #17은 다음과 같은 이진트리로 표현할 수 있습니다.42는 다음과 같은 이진트리로 표현할 수 있습니다.5는 이진트리로 표현할 수 없습니다.따라서, [1, 0]을 return 하면 됩니다.입출력 예 #263은 다음과 같은 이진트리로 표현할 수 있습니다.111은 다음과 같은 이진트리로 표현할 수 있습니다.95는 이진트리로 표현할 수 없습니다.따라서, [1, 1, 0]을 return 하면 됩니다.",1
49,표 병합,"당신은 표 편집 프로그램을 작성하고 있습니다.표의 크기는 50 × 50으로 고정되어있고 초기에 모든 셀은 비어 있습니다.각 셀은 문자열 값을 가질 수 있고, 다른 셀과 병합될 수 있습니다.위에서r번째, 왼쪽에서c번째 위치를 (r,c)라고 표현할 때, 당신은 다음 명령어들에 대한 기능을 구현하려고 합니다.""UPDATE r c value""(r,c) 위치의 셀을 선택합니다.선택한 셀의 값을value로 바꿉니다.""UPDATE value1 value2""value1을 값으로 가지고 있는 모든 셀을 선택합니다.선택한 셀의 값을value2로 바꿉니다.""MERGE r1 c1 r2 c2""(r1,c1) 위치의 셀과 (r2,c2) 위치의 셀을 선택하여 병합합니다.선택한 두 위치의 셀이 같은 셀일 경우 무시합니다.선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1,c1) 위치의 셀과 (r2,c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다.두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다.두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1,c1) 위치의 셀 값을 가지게 됩니다.이후 (r1,c1) 와 (r2,c2) 중 어느 위치를 선택하여도 병합된 셀로 접근합니다.""UNMERGE r c""(r,c) 위치의 셀을 선택하여 해당 셀의 모든 병합을 해제합니다.선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아갑니다.병합을 해제하기 전 셀이 값을 가지고 있었을 경우 (r,c) 위치의 셀이 그 값을 가지게 됩니다.""PRINT r c""(r,c) 위치의 셀을 선택하여 셀의 값을 출력합니다.선택한 셀이 비어있을 경우""EMPTY""를 출력합니다.아래는UPDATE명령어를 실행하여 빈 셀에 값을 입력하는 예시입니다.commands효과UPDATE 1 1 menu(1,1)에""menu""입력UPDATE 1 2 category(1,2)에""category""입력UPDATE 2 1 bibimbap(2,1)에""bibimbap""입력UPDATE 2 2 korean(2,2)에""korean""입력UPDATE 2 3 rice(2,3)에""rice""입력UPDATE 3 1 ramyeon(3,1)에""ramyeon""입력UPDATE 3 2 korean(3,2)에""korean""입력UPDATE 3 3 noodle(3,3)에""noodle""입력UPDATE 3 4 instant(3,4)에""instant""입력UPDATE 4 1 pasta(4,1)에""pasta""입력UPDATE 4 2 italian(4,2)에""italian""입력UPDATE 4 3 noodle(4,3)에""noodle""입력위 명령어를 실행하면 아래 그림과 같은 상태가 됩니다.아래는MERGE명령어를 실행하여 셀을 병합하는 예시입니다.commands효과MERGE 1 2 1 3(1,2)와 (1,3) 병합MERGE 1 3 1 4(1,3)과 (1,4) 병합위 명령어를 실행하면 아래와 같은 상태가 됩니다.병합한 셀은""category""값을 가지게 되며 (1,2), (1,3), (1,4) 중 어느 위치를 선택하더라도 접근할 수 있습니다.아래는UPDATE명령어를 실행하여 셀의 값을 변경하는 예시입니다.commands효과UPDATE korean hansik""korean""을""hansik""으로 변경UPDATE 1 3 group(1,3) 위치의 셀 값을""group""으로 변경위 명령어를 실행하면 아래와 같은 상태가 됩니다.아래는UNMERGE명령어를 실행하여 셀의 병합을 해제하는 예시입니다.commands효과UNMERGE 1 4셀 병합 해제 후 원래 값은 (1,4)가 가짐위 명령어를 실행하면 아래와 같은 상태가 됩니다.실행할 명령어들이 담긴 1차원 문자열 배열commands가 매개변수로 주어집니다.commands의 명령어들을 순서대로 실행하였을 때,""PRINT r c""명령어에 대한 실행결과를 순서대로 1차원 문자열 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항1 ≤commands의 길이 ≤ 1,000commands의 각 원소는 아래 5가지 형태 중 하나입니다.""UPDATE r c value""r,c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.value는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다.""UPDATE value1 value2""value1은 선택할 셀의 값,value2는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다.""MERGE r1 c1 r2 c2""r1,c1,r2,c2는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.""UNMERGE r c""r,c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.""PRINT r c""r,c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.commands는 1개 이상의""PRINT r c""명령어를 포함하고 있습니다.입출력 예commandsresult[""UPDATE 1 1 menu"", ""UPDATE 1 2 category"", ""UPDATE 2 1 bibimbap"", ""UPDATE 2 2 korean"", ""UPDATE 2 3 rice"", ""UPDATE 3 1 ramyeon"", ""UPDATE 3 2 korean"", ""UPDATE 3 3 noodle"", ""UPDATE 3 4 instant"", ""UPDATE 4 1 pasta"", ""UPDATE 4 2 italian"", ""UPDATE 4 3 noodle"", ""MERGE 1 2 1 3"", ""MERGE 1 3 1 4"", ""UPDATE korean hansik"", ""UPDATE 1 3 group"", ""UNMERGE 1 4"", ""PRINT 1 3"", ""PRINT 1 4""][""EMPTY"", ""group""][""UPDATE 1 1 a"", ""UPDATE 1 2 b"", ""UPDATE 2 1 c"", ""UPDATE 2 2 d"", ""MERGE 1 1 1 2"", ""MERGE 2 2 2 1"", ""MERGE 2 1 1 1"", ""PRINT 1 1"", ""UNMERGE 2 2"", ""PRINT 1 1""][""d"", ""EMPTY""]입출력 예 설명입출력 예 #1문제 예시와 같습니다. (1,3) 위치의 셀은 비어있고 (1,4) 위치의 셀 값은""group""입니다. 따라서[""EMPTY"", ""group""]을 return 해야 합니다.입출력 예 #2모든UPDATE명령어를 실행하면 아래와 같은 상태가 됩니다.""MERGE 1 1 1 2""명령어를 실행하면 아래와 같은 상태가 됩니다.""MERGE 2 2 2 1""명령어를 실행하면 아래와 같은 상태가 됩니다.""MERGE 2 1 1 1""명령어를 실행하면 아래와 같은 상태가 됩니다.""UNMERGE 2 2""명령어를 실행하면 아래와 같은 상태가 됩니다.",1
50,미로 탈출 명령어,"nxm격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다.단, 미로를 탈출하는 조건이 세 가지 있습니다.격자의 바깥으로는 나갈 수 없습니다.(x, y)에서 (r, c)까지 이동하는 거리가 총k여야 합니다.이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.l: 왼쪽으로 한 칸 이동r: 오른쪽으로 한 칸 이동u: 위쪽으로 한 칸 이동d: 아래쪽으로 한 칸 이동예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열""lul""로 나타낼 수 있습니다.미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다.예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다.....
..S.
E...미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다..은 빈 공간,S는 출발 지점,E는 탈출 지점입니다.탈출까지 이동해야 하는 거리k가 5라면 다음과 같은 경로로 탈출할 수 있습니다.lldudullddrdllldllrldllud...이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다.격자의 크기를 뜻하는 정수n,m, 출발 위치를 뜻하는 정수x,y, 탈출 지점을 뜻하는 정수r,c, 탈출까지 이동해야 하는 거리를 뜻하는 정수k가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요.단, 위 조건대로 미로를 탈출할 수 없는 경우""impossible""을 return 해야 합니다.제한사항2 ≤n(= 미로의 세로 길이) ≤ 502 ≤m(= 미로의 가로 길이) ≤ 501 ≤x≤n1 ≤y≤m1 ≤r≤n1 ≤c≤m(x,y) ≠ (r,c)1 ≤k≤ 2,500입출력 예nmxyrckresult3423315""dllrl""2211222""dr""3312334""impossible""입출력 예 설명입출력 예 #1문제 예시와 동일합니다.입출력 예 #2미로의 크기는 2 x 2입니다. 출발 지점은 (1, 1)이고, 탈출 지점은 (2, 2)입니다.빈 공간은., 출발 지점을S, 탈출 지점을E로 나타내면 다음과 같습니다.S.
.E미로의 좌측 상단은 (1, 1)이고 우측 하단은 (2, 2)입니다.탈출까지 이동해야 하는 거리k가 2이므로 다음과 같은 경로로 탈출할 수 있습니다.rddr""dr""이 사전 순으로 가장 빠른 경로입니다. 따라서""dr""을 return 해야 합니다.입출력 예 #3미로의 크기는 3 x 3입니다. 출발 지점은 (1, 2)이고, 탈출 지점은 (3, 3)입니다.빈 공간은., 출발 지점을S, 탈출 지점을E로 나타내면 다음과 같습니다..S.
...
..E미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 3)입니다.탈출까지 이동해야 하는 거리k가 4입니다. 이때, 이동 거리가 4이면서,S에서E까지 이동할 수 있는 경로는 존재하지 않습니다.따라서""impossible""을 return 해야 합니다.",1
51,"1,2,3 떨어트리기","춘식이는 트리의 1번 노드에 숫자 1, 2, 3 중 하나씩을 계속해서 떨어트려 트리의 리프 노드1에 숫자를 쌓는 게임을 하려고 합니다.아래 그림은 게임의 예시를 나타냅니다.트리의 모든 간선은 부모 노드가 자식 노드를 가리키는 단방향 간선입니다.모든 부모 노드는 자식 노드와 연결된 간선 중 하나를 길로 설정합니다.실선 화살표는 길인 간선입니다.점선 화살표는 길이 아닌 간선입니다.모든 부모 노드는 자신의 자식 노드 중 가장 번호가 작은 노드를 가리키는 간선을 초기 길로 설정합니다.[게임의 규칙]은 아래와 같습니다.1번 노드(루트 노드)에 숫자 1, 2, 3 중 하나를 떨어트립니다.숫자는 길인 간선을 따라 리프 노드까지 떨어집니다.숫자가 리프 노드에 도착하면, 숫자가 지나간 각 노드는현재 길로 연결된 자식 노드 다음으로 번호가 큰 자식 노드를 가리키는 간선을 새로운 길로 설정하고 기존의 길은 끊습니다.만약 현재 길로 연결된 노드의 번호가 가장 크면, 번호가 가장 작은 노드를 가리키는 간선을 길로 설정합니다.노드의 간선이 하나라면 계속 하나의 간선을 길로 설정합니다.원하는 만큼 계속해서 루트 노드에 숫자를 떨어트릴 수 있습니다.단, 앞서 떨어트린 숫자가 리프 노드까지 떨어진 후에 새로운 숫자를 떨어트려야 합니다.[게임의 목표]는 각각의 리프 노드에 쌓인 숫자의 합을target에서 가리키는 값과 같게 만드는 것입니다.예를 들어,target이 [0, 0, 0, 3, 0, 0, 5, 1, 2, 3]일 경우 아래 표와 같은 의미를 가집니다.노드 번호노드에 쌓인 숫자의 합102030435060758192103target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해서는 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 됩니다.아래 두 그림은 순서대로 1, 2번째 숫자 [2, 1]을 떨어트린 뒤의 길 상황을 나타냅니다.숫자 2는 떨어지면서 1번 노드와 2번 노드를 지나갔습니다.1번 노드는 3번 노드를 가리키는 간선을 길로 설정합니다.2번 노드는 5번 노드를 가리키는 간선을 길로 설정합니다.숫자 1은 떨어지면서 1번 노드, 3번 노드, 6번 노드를 지나갔습니다.1번 노드는 3번 노드보다 번호가 큰 노드를 가리키는 간선이 없으므로 다시 2번 노드를 가리키는 간선을 길로 설정합니다.3번 노드는 간선이 하나이므로 계속해서 6번 노드를 가리키는 간선을 길로 설정합니다.6번 노드는 9번 노드를 가리키는 간선을 길로 설정합니다.아래 두 그림은 순서대로 3, 4번째 숫자 [2, 2]를 떨어트린 뒤의 길 상황을 나타냅니다.아래 세 그림은 순서대로 5, 6, 7번째 숫자 [1, 3, 3]을 떨어트린 뒤의 길 상황을 나타냅니다.각 리프 노드에 쌓인 숫자를 모두 더해 배열로 나타내면target과 같습니다.트리의 각 노드들의 연결 관계를 담은 2차원 정수 배열edges, 각 노드별로 만들어야 하는 숫자의 합을 담은 1차원 정수 배열target이 매개변수로 주어집니다. 이때,target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해 숫자를 떨어트리는 모든 경우 중 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우를 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 만약,target대로 숫자의 합을 만들 수 없는 경우[-1]을 return 해주세요.제한사항1 ≤edges의 길이 ≤ 100edges[i]는 [부모 노드 번호, 자식 노드 번호] 형태로, 단방향으로 연결된 두 노드를 나타냅니다.1 ≤ 노드 번호 ≤edges의 길이 + 1동일한 간선에 대한 정보가 중복해서 주어지지 않습니다.항상 하나의 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다.1번 노드는 항상 루트 노드입니다.target의 길이 =edges의 길이 + 1target[i]는 i + 1번 노드에 쌓인 숫자의 합으로 만들어야 하는 수를 나타냅니다.0 ≤ 리프 노드의target값 ≤ 100리프 노드를 제외한 노드의target값 = 0target의 원소의 합은 1 이상입니다.입출력 예edgestargetresult[[2, 4], [1, 2], [6, 8], [1, 3], [5, 7], [2, 5], [3, 6], [6, 10], [6, 9]][0, 0, 0, 3, 0, 0, 5, 1, 2, 3][1, 1, 2, 2, 2, 3, 3][[1, 2], [1, 3]][0, 7, 3][1, 1, 3, 2, 3][[1, 3], [1, 2]][0, 7, 1][-1]입출력 예 설명입출력 예 #1문제 예시와 같습니다. 위의 설명처럼 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 2, 2, 2, 3, 3]입니다.입출력 예 #2[3, 2, 1, 1, 3]순으로 숫자를 떨어트리거나 [1, 1, 1, 1, 2, 1, 3]순으로 숫자를 떨어트려도 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 3, 2, 3]입니다.입출력 예 #3예제 3번의 트리는 주어지는edges의 순서만 다를 뿐, 예제 2번과 같은 트리입니다. 2번 노드에 쌓인 숫자의 합을 7로 만들면서 3번 노드에 쌓인 숫자의 합을 1로 만들도록 숫자를 떨어트리는 방법은 없습니다.따라서 [-1]을 return 해야 합니다.리프 노드는 자식 노드가 없는 노드를 뜻합니다.↩",1
52,사라지는 발판,"문제 설명플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다.각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다.다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다.움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다.두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다.게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다.아래 그림은 초기 보드의 상태와 각 플레이어의 위치를 나타내는 예시입니다.위와 같은 경우, 플레이어 A는 실수만 하지 않는다면 항상 이길 수 있습니다. 따라서 플레이어 A는 이길 수 있는 플레이어이며, B는 질 수밖에 없는 플레이어입니다. 다음은 A와 B가 최적의 플레이를 하는 과정을 나타냅니다.플레이어 A가 초기 위치 (1, 0)에서 (1, 1)로 이동합니다.플레이어 A가 (0, 0)이나 (2, 0)으로 이동할 경우 승리를 보장할 수 없습니다. 따라서 무조건 이길 방법이 있는 (1, 1)로 이동합니다.플레이어 B는 (1, 1)로 이동할 경우, 바로 다음 차례에 A가 위 또는 아래 방향으로 이동하면 발판이 없어져 패배하게 됩니다.질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이하기 때문에 (1, 1)로 이동하지 않습니다.(1, 2)에서 위쪽 칸인 (0, 2)로 이동합니다.A가 (1, 1)에서 (0, 1)로 이동합니다.B에게는 남은 선택지가 (0, 1)밖에 없습니다. 따라서 (0, 2)에서 (0, 1)로 이동합니다.A가 (0, 1)에서 (0, 0)으로 이동합니다. 이동을 완료함과 동시에 B가 서있던 (0, 1)의 발판이 사라집니다. B가 패배합니다.만약 과정 2에서 B가 아래쪽 칸인 (2, 2)로 이동하더라도 A는 (2, 1)로 이동하면 됩니다. 이후 B가 (2, 1)로 이동, 다음 차례에 A가 (2, 0)으로 이동하면 B가 패배합니다.위 예시에서 양 플레이어가 최적의 플레이를 했을 경우, 캐릭터의 이동 횟수 합은 5입니다. 최적의 플레이를 하는 방법은 여러 가지일 수 있으나, 이동한 횟수는 모두 5로 같습니다.게임 보드의 초기 상태를 나타내는 2차원 정수 배열board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요.제한사항1 ≤board의 세로 길이 ≤ 51 ≤board의 가로 길이 ≤ 5board의 원소는 0 또는 1입니다.0은 발판이 없음을, 1은 발판이 있음을 나타냅니다.게임 보드의 좌측 상단 좌표는 (0, 0), 우측 하단 좌표는 (board의 세로 길이 - 1,board의 가로 길이 - 1)입니다.aloc과bloc은 각각 플레이어 A의 캐릭터와 플레이어 B의 캐릭터 초기 위치를 나타내는 좌표값이며 [r, c] 형태입니다.r은 몇 번째 행인지를 나타냅니다.0 ≤ r <board의 세로 길이c는 몇 번째 열인지를 나타냅니다.0 ≤ c <board의 가로 길이초기 보드의aloc과bloc위치는 항상 발판이 있는 곳입니다.aloc과bloc이 같을 수 있습니다.상대 플레이어의 캐릭터가 있는 칸으로 이동할 수 있습니다.입출력 예boardalocblocresult[[1, 1, 1], [1, 1, 1], [1, 1, 1]][1, 0][1, 2]5[[1, 1, 1], [1, 0, 1], [1, 1, 1]][1, 0][1, 2]4[[1, 1, 1, 1, 1]][0, 0][0, 4]4[[1]][0, 0][0, 0]0입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2주어진 조건을 그림으로 나타내면 아래와 같습니다.항상 이기는 플레이어는 B, 항상 지는 플레이어는 A입니다.다음은 B가 이기는 방법 중 하나입니다.A가 (1, 0)에서 (0, 0)으로 이동B가 (1, 2)에서 (2, 2)로 이동A가 (0, 0)에서 (0, 1)로 이동B가 (2, 2)에서 (2, 1)로 이동A가 (0, 1)에서 (0, 2)로 이동B가 (2, 1)에서 (2, 0)으로 이동A는 더 이상 이동할 수 없어 패배합니다.위와 같이 플레이할 경우 이동 횟수 6번 만에 게임을 B의 승리로 끝낼 수 있습니다.B가 다음과 같이 플레이할 경우 게임을 더 빨리 끝낼 수 있습니다. 이길 수 있는 플레이어는 최대한 빨리 게임을 끝내려 하기 때문에 위 방법 대신 아래 방법을 선택합니다.A가 (1, 0)에서 (0, 0)으로 이동B가 (1, 2)에서 (0, 2)로 이동A가 (0, 0)에서 (0, 1)로 이동B가 (0, 2)에서 (0, 1)로 이동A는 더 이상 이동할 수 없어 패배합니다.위와 같이 플레이할 경우 이동 횟수 4번 만에 게임을 B의 승리로 끝낼 수 있습니다. 따라서 4를 return 합니다.입출력 예 #3양 플레이어는 매 차례마다 한 가지 선택지밖에 고를 수 없습니다. 그 결과, (0, 2)에서 어디로도 이동할 수 없는 A가 패배합니다. 양 플레이어가 캐릭터를 움직인 횟수의 합은 4입니다.입출력 예 #4게임을 시작하는 플레이어 A가 처음부터 어디로도 이동할 수 없는 상태입니다. 따라서 A의 패배이며, 이동 횟수의 합은 0입니다.제한시간 안내정확성 테스트 : 10초",1
53,파괴되지 않은 건물,"문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다.첫 번째로 적이 맵의(0,0)부터 (3,4)까지 공격하여 4만큼건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.두 번째로 적이 맵의(2,0)부터 (2,3)까지 공격하여 2만큼건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다.세 번째로 아군이 맵의(1,0)부터 (3,1)까지 회복하여 2만큼건물의 내구도를 높이면 아래와 같이2개의 건물이 파괴되었다가 복구되고 2개의 건물만 파괴되어있는 상태가 됩니다.마지막으로 적이 맵의(0,1)부터 (3,3)까지 공격하여 1만큼건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다.(내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.)최종적으로 총 10개의 건물이 파괴되지 않았습니다.건물의 내구도를 나타내는 2차원 정수 배열board와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열skill이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.제한사항1 ≤board의 행의 길이 (=N) ≤ 1,0001 ≤board의 열의 길이 (=M) ≤ 1,0001 ≤board의 원소 (각 건물의 내구도) ≤ 1,0001 ≤skill의 행의 길이 ≤ 250,000skill의 열의 길이  = 6skill의 각 행은[type, r1, c1, r2, c2, degree]형태를 가지고 있습니다.type은 1 혹은 2입니다.type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다.type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다.(r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다.0 ≤ r1 ≤ r2 <board의 행의 길이0 ≤ c1 ≤ c2 <board의 열의 길이1 ≤ degree ≤ 500type이 1이면 degree만큼 건물의 내구도를 낮춥니다.type이 2이면 degree만큼 건물의 내구도를 높입니다.건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다.정확성 테스트 케이스 제한 사항1 ≤board의 행의 길이 (=N) ≤ 1001 ≤board의 열의 길이 (=M) ≤ 1001 ≤board의 원소 (각 건물의 내구도) ≤ 1001 ≤skill의 행의 길이 ≤ 1001 ≤ degree ≤ 100효율성 테스트 케이스 제한 사항주어진 조건 외 추가 제한사항 없습니다.입출력 예boardskillresult[[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]][[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]10[[1,2,3],[4,5,6],[7,8,9]][[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]6입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2<초기 맵 상태>첫 번째로 적이 맵의(1,1)부터 (2,2)까지 공격하여 4만큼건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.두 번째로 적이 맵의(0,0)부터 (1,1)까지 공격하여 2만큼건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.마지막으로 아군이 맵의(2,0)부터 (2,0)까지 회복하여 100만큼건물의 내구도를 높이면 아래와 같은 상황이 됩니다.총, 6개의 건물이 파괴되지 않았습니다. 따라서 6을 return 해야 합니다.제한시간 안내정확성 테스트 : 10초효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",1
54,양과 늑대,"문제 설명2진 트리 모양 초원의 각 노드에 늑대와 양이 한 마리씩 놓여 있습니다. 이 초원의 루트 노드에서 출발하여 각 노드를 돌아다니며 양을 모으려 합니다. 각 노드를 방문할 때 마다 해당 노드에 있던 양과 늑대가 당신을 따라오게 됩니다. 이때, 늑대는 양을 잡아먹을 기회를 노리고 있으며, 당신이 모은 양의 수보다 늑대의 수가 같거나 더 많아지면 바로 모든 양을 잡아먹어 버립니다. 당신은 중간에 양이 늑대에게 잡아먹히지 않도록 하면서 최대한 많은 수의 양을 모아서 다시 루트 노드로 돌아오려 합니다.예를 들어, 위 그림의 경우(루트 노드에는 항상 양이 있습니다) 0번 노드(루트 노드)에서 출발하면 양을 한마리 모을 수 있습니다. 다음으로 1번 노드로 이동하면 당신이 모은 양은 두 마리가 됩니다. 이때, 바로 4번 노드로 이동하면 늑대 한 마리가 당신을 따라오게 됩니다. 아직은 양 2마리, 늑대 1마리로 양이 잡아먹히지 않지만, 이후에 갈 수 있는 아직 방문하지 않은 모든 노드(2, 3, 6, 8번)에는 늑대가 있습니다. 이어서 늑대가 있는 노드로 이동한다면(예를 들어 바로 6번 노드로 이동한다면) 양 2마리, 늑대 2마리가 되어 양이 모두 잡아먹힙니다. 여기서는 0번, 1번 노드를 방문하여 양을 2마리 모은 후, 8번 노드로 이동한 후(양 2마리 늑대 1마리) 이어서 7번, 9번 노드를 방문하면 양 4마리 늑대 1마리가 됩니다. 이제 4번, 6번 노드로 이동하면 양 4마리, 늑대 3마리가 되며, 이제 5번 노드로 이동할 수 있게 됩니다. 따라서 양을 최대 5마리 모을 수 있습니다.각 노드에 있는 양 또는 늑대에 대한 정보가 담긴 배열info, 2진 트리의 각 노드들의 연결 관계를 담은 2차원 배열edges가 매개변수로 주어질 때, 문제에 제시된 조건에 따라 각 노드를 방문하면서 모을 수 있는 양은 최대 몇 마리인지 return 하도록 solution 함수를 완성해주세요.제한사항2 ≤info의 길이 ≤ 17info의 원소는 0 또는 1 입니다.info[i]는 i번 노드에 있는 양 또는 늑대를 나타냅니다.0은 양, 1은 늑대를 의미합니다.info[0]의 값은 항상 0입니다. 즉, 0번 노드(루트 노드)에는 항상 양이 있습니다.edges의 세로(행) 길이 =info의 길이 - 1edges의 가로(열) 길이 = 2edges의 각 행은 [부모 노드 번호, 자식 노드 번호] 형태로, 서로 연결된 두 노드를 나타냅니다.동일한 간선에 대한 정보가 중복해서 주어지지 않습니다.항상 하나의 이진 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다.0번 노드는 항상 루트 노드입니다.입출력 예infoedgesresult[0,0,1,1,1,0,1,0,1,0,1,1][[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]5[0,1,0,1,1,0,1,0,0,1,0][[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]5입출력 예 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2주어진 입력은 다음 그림과 같습니다.0번 - 2번 - 5번 - 1번 - 4번 - 8번 - 3번 - 7번 노드 순으로 이동하면 양 5마리 늑대 3마리가 됩니다. 여기서 6번, 9번 노드로 이동하면 양 5마리, 늑대 5마리가 되어 양이 모두 잡아먹히게 됩니다. 따라서 늑대에게 잡아먹히지 않도록 하면서 최대로 모을 수 있는 양은 5마리입니다.제한시간 안내정확성 테스트 : 10초",1
55,양궁대회,"문제 설명카카오배 양궁대회가 열렸습니다.라이언은 저번 카카오배 양궁대회 우승자이고 이번 대회에도 결승전까지 올라왔습니다. 결승전 상대는어피치입니다.카카오배 양궁대회 운영위원회는 한 선수의 연속 우승보다는 다양한 선수들이 양궁대회에서 우승하기를 원합니다. 따라서, 양궁대회 운영위원회는 결승전 규칙을 전 대회 우승자인 라이언에게 불리하게 다음과 같이 정했습니다.어피치가 화살n발을 다 쏜 후에 라이언이 화살n발을 쏩니다.점수를 계산합니다.과녁판은 아래 사진처럼 생겼으며 가장 작은 원의 과녁 점수는 10점이고 가장 큰 원의 바깥쪽은 과녁 점수가 0점입니다.만약, k(k는 1~10사이의 자연수)점을 어피치가 a발을 맞혔고 라이언이 b발을 맞혔을 경우 더 많은 화살을 k점에 맞힌 선수가 k 점을 가져갑니다. 단, a = b일 경우는 어피치가 k점을 가져갑니다.k점을 여러 발 맞혀도 k점 보다 많은 점수를 가져가는 게 아니고 k점만 가져가는 것을 유의하세요. 또한 a = b = 0 인 경우, 즉, 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다.예를 들어, 어피치가 10점을 2발 맞혔고 라이언도 10점을 2발 맞혔을 경우 어피치가 10점을 가져갑니다.다른 예로, 어피치가 10점을 0발 맞혔고 라이언이 10점을 2발 맞혔을 경우 라이언이 10점을 가져갑니다.모든 과녁 점수에 대하여 각 선수의 최종 점수를 계산합니다.최종 점수가 더 높은 선수를 우승자로 결정합니다. 단, 최종 점수가 같을 경우 어피치를 우승자로 결정합니다.현재 상황은 어피치가 화살n발을 다 쏜 후이고 라이언이 화살을 쏠 차례입니다.라이언은 어피치를 가장 큰 점수 차이로 이기기 위해서n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 구하려고 합니다.화살의 개수를 담은 자연수n, 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열info가 매개변수로 주어집니다. 이때, 라이언이 가장 큰 점수 차이로 우승하기 위해n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약, 라이언이 우승할 수 없는 경우(무조건 지거나 비기는 경우)는[-1]을 return 해주세요.제한사항1 ≤n≤ 10info의 길이 = 110 ≤info의 원소 ≤ninfo의 원소 총합 =ninfo의 i번째 원소는 과녁의10 - i점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.)라이언이 우승할 방법이 있는 경우, return 할 정수 배열의 길이는 11입니다.0 ≤ return할 정수 배열의 원소 ≤nreturn할 정수 배열의 원소 총합 =n(꼭 n발을 다 쏴야 합니다.)return할 정수 배열의 i번째 원소는 과녁의10 - i점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.)라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.가장 낮은 점수를 맞힌 개수가 같을 경우 계속해서 그다음으로 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.예를 들어,[2,3,1,0,0,0,0,1,3,0,0]과[2,1,0,2,0,0,0,2,3,0,0]를 비교하면[2,1,0,2,0,0,0,2,3,0,0]를 return 해야 합니다.다른 예로,[0,0,2,3,4,1,0,0,0,0,0]과[9,0,0,0,0,0,0,0,1,0,0]를 비교하면[9,0,0,0,0,0,0,0,1,0,0]를 return 해야 합니다.라이언이 우승할 방법이 없는 경우, return 할 정수 배열의 길이는 1입니다.라이언이 어떻게 화살을 쏘든라이언의 점수가 어피치의 점수보다 낮거나 같으면[-1]을 return 해야 합니다.입출력 예ninforesult5[2,1,1,1,0,0,0,0,0,0,0][0,2,2,0,1,0,0,0,0,0,0]1[1,0,0,0,0,0,0,0,0,0,0][-1]9[0,0,1,2,0,1,1,1,1,1,1][1,1,2,0,1,2,2,0,0,0,0]10[0,0,0,0,0,0,0,0,3,4,3][1,1,1,1,1,1,1,1,0,0,2]입출력 예 설명입출력 예 #1어피치와 라이언이 아래와 같이 화살을 맞힐 경우,과녁 점수어피치가 맞힌 화살 개수라이언이 맞힌 화살 개수결과1023라이언이 10점 획득912라이언이 9점 획득810어피치가 8점 획득710어피치가 7점 획득600500400300200100000어피치의 최종 점수는 15점, 라이언의 최종 점수는 19점입니다. 4점 차이로 라이언이 우승합니다.하지만, 라이언이 아래와 같이 화살을 맞힐 경우 더 큰 점수 차로 우승할 수 있습니다.과녁 점수어피치가 맞힌 화살 개수라이언이 맞힌 화살 개수결과1020어피치가 10점 획득912라이언이 9점 획득812라이언이 8점 획득710어피치가 7점 획득601라이언이 6점 획득500400300200100000어피치의 최종 점수는 17점, 라이언의 최종 점수는 23점입니다. 6점 차이로 라이언이 우승합니다.따라서[0,2,2,0,1,0,0,0,0,0,0]을 return 해야 합니다.입출력 예 #2라이언이 10점을 맞혀도 어피치가 10점을 가져가게 됩니다.따라서, 라이언은 우승할 수 없기 때문에[-1]을 return 해야 합니다.입출력 예 #3어피치와 라이언이 아래와 같이 화살을 맞힐 경우,과녁 점수어피치가 맞힌 화살 개수라이언이 맞힌 화살 개수결과1001라이언이 10점 획득901라이언이 9점 획득812라이언이 8점 획득723라이언이 7점 획득600512라이언이 5점 획득410어피치가 4점 획득310어피치가 3점 획득210어피치가 2점 획득110어피치가 1점 획득010어피치가 0점 획득어피치의 최종 점수는 10점, 라이언의 최종 점수는 39점입니다. 29점 차이로 라이언이 우승합니다.하지만 라이언이 아래와 같이 화살을 맞힐 경우,과녁 점수어피치가 맞힌 화살 개수라이언이 맞힌 화살 개수결과1001라이언이 10점 획득901라이언이 9점 획득812라이언이 8점 획득720어피치가 7점 획득601라이언이 6점 획득512라이언이 5점 획득412라이언이 4점 획득310어피치가 3점 획득210어피치가 2점 획득110어피치가 1점 획득010어피치가 0점 획득어피치의 최종 점수는 13점, 라이언의 최종 점수는 42점입니다. 이 경우도 29점 차이로 라이언이 우승합니다.하지만, 첫 번째 경우와 두 번째 경우를 비교했을 때, 두 번째 경우가 두 경우 중 가장 낮은 점수인 4점을 더 많이 맞혔기 때문에[1,1,2,3,0,2,0,0,0,0,0]이 아닌[1,1,2,0,1,2,2,0,0,0,0]을 return 해야 합니다.입출력 예 #4가장 큰 점수 차이로 이기는 경우 중에서 가장 낮은 점수를 가장 많이 맞힌, 10~3점을 한 발씩 맞히고 나머지 두 발을 0점에 맞히는 경우인[1,1,1,1,1,1,1,1,0,0,2]를 return 해야 합니다.제한시간 안내정확성 테스트 : 10초",1
56,주차 요금 계산,"문제 설명주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.요금표기본 시간(분)기본 요금(원)단위 시간(분)단위 요금(원)180500010600입/출차 기록시각(시:분)차량 번호내역05:345961입차06:000000입차06:340000출차07:595961출차07:590148입차18:590000입차19:090148출차22:595961입차23:005961출차자동차별 주차 요금차량 번호누적 주차 시간(분)주차 요금(원)000034 + 300 = 3345000 +⌈(334 - 180) / 10⌉x 600 = 1460001486705000 +⌈(670 - 180) / 10⌉x 600 = 344005961145 + 1 = 1465000어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.누적 주차 시간이기본 시간이하라면,기본 요금을 청구합니다.누적 주차 시간이기본 시간을 초과하면,기본 요금에 더해서, 초과한 시간에 대해서단위 시간마다단위 요금을 청구합니다.초과한 시간이단위 시간으로 나누어 떨어지지 않으면,올림합니다.⌈a⌉: a보다 작지 않은 최소의 정수를 의미합니다. 즉,올림을 의미합니다.주차 요금을 나타내는 정수 배열fees, 자동차의 입/출차 내역을 나타내는 문자열 배열records가 매개변수로 주어집니다.차량 번호가 작은 자동차부터청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.제한사항fees의 길이 = 4fees[0] =기본 시간(분)1 ≤ fees[0] ≤ 1,439fees[1] =기본 요금(원)0 ≤ fees[1] ≤ 100,000fees[2] =단위 시간(분)1 ≤ fees[2] ≤ 1,439fees[3] =단위 요금(원)1 ≤ fees[3] ≤ 10,0001 ≤records의 길이 ≤ 1,000records의 각 원소는""시각 차량번호 내역""형식의 문자열입니다.시각,차량번호,내역은 하나의 공백으로 구분되어 있습니다.시각은 차량이 입차되거나 출차된 시각을 나타내며,HH:MM형식의 길이 5인 문자열입니다.HH:MM은 00:00부터 23:59까지 주어집니다.잘못된 시각(""25:22"", ""09:65"" 등)은 입력으로 주어지지 않습니다.차량번호는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다.내역은 길이 2 또는 3인 문자열로,IN또는OUT입니다.IN은 입차를,OUT은 출차를 의미합니다.records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.주차장에 없는 차량이 출차되는 경우주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우입출력 예feesrecordsresult[180, 5000, 10, 600][""05:34 5961 IN"", ""06:00 0000 IN"", ""06:34 0000 OUT"", ""07:59 5961 OUT"", ""07:59 0148 IN"", ""18:59 0000 IN"", ""19:09 0148 OUT"", ""22:59 5961 IN"", ""23:00 5961 OUT""][14600, 34400, 5000][120, 0, 60, 591][""16:00 3961 IN"",""16:00 0202 IN"",""18:00 3961 OUT"",""18:00 0202 OUT"",""23:58 3961 IN""][0, 591][1, 461, 1, 10][""00:00 1234 IN""][14841]입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2요금표기본 시간(분)기본 요금(원)단위 시간(분)단위 요금(원)120060591입/출차 기록시각(시:분)차량 번호내역16:003961입차16:000202입차18:003961출차18:000202출차23:583961입차자동차별 주차 요금차량 번호누적 주차 시간(분)주차 요금(원)020212003961120 + 1 = 1210 +⌈(121 - 120) / 60⌉x 591 = 5913961번 차량은 2번째 입차된 후에는 출차된 내역이 없으므로, 23:59에 출차되었다고 간주합니다.입출력 예 #3요금표기본 시간(분)기본 요금(원)단위 시간(분)단위 요금(원)1461110입/출차 기록시각(시:분)차량 번호내역00:001234입차자동차별 주차 요금차량 번호누적 주차 시간(분)주차 요금(원)12341439461 +⌈(1439 - 1) / 1⌉x 10 = 148411234번 차량은 출차 내역이 없으므로, 23:59에 출차되었다고 간주합니다.​제한시간 안내정확성 테스트 : 10초",1
57,k진수에서 소수 개수 구하기,"문제 설명양의 정수n이 주어집니다. 이 숫자를k진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다.0P0처럼 소수 양쪽에 0이 있는 경우P0처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우0P처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우P처럼 소수 양쪽에 아무것도 없는 경우단,P는 각 자릿수에 0을 포함하지 않는 소수입니다.예를 들어, 101은P가 될 수 없습니다.예를 들어, 437674을 3진수로 바꾸면211020101011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을k진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은P0형태에서 찾을 수 있으며, 2는0P0에서, 11은0P에서 찾을 수 있습니다.정수n과k가 매개변수로 주어집니다.n을k진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요.제한사항1 ≤n≤ 1,000,0003 ≤k≤ 10입출력 예nkresult43767433110011102입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2110011을 10진수로 바꾸면 110011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 11, 11 2개입니다. 이와 같이, 중복되는 소수를 발견하더라도 모두 따로 세어야 합니다.문제가 잘 안풀린다면😢힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! →클릭",1
58,신고 결과 받기,"문제 설명신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다.각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다.신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다.한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다.k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다.유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다.다음은 전체 유저 목록이 [""muzi"", ""frodo"", ""apeach"", ""neo""]이고, k = 2(즉, 2번 이상 신고당하면 이용 정지)인 경우의 예시입니다.유저 ID유저가 신고한 ID설명""muzi""""frodo""""muzi""가 ""frodo""를 신고했습니다.""apeach""""frodo""""apeach""가 ""frodo""를 신고했습니다.""frodo""""neo""""frodo""가 ""neo""를 신고했습니다.""muzi""""neo""""muzi""가 ""neo""를 신고했습니다.""apeach""""muzi""""apeach""가 ""muzi""를 신고했습니다.각 유저별로 신고당한 횟수는 다음과 같습니다.유저 ID신고당한 횟수""muzi""1""frodo""2""apeach""0""neo""2위 예시에서는 2번 이상 신고당한 ""frodo""와 ""neo""의 게시판 이용이 정지됩니다. 이때, 각 유저별로 신고한 아이디와 정지된 아이디를 정리하면 다음과 같습니다.유저 ID유저가 신고한 ID정지된 ID""muzi""[""frodo"", ""neo""][""frodo"", ""neo""]""frodo""[""neo""][""neo""]""apeach""[""muzi"", ""frodo""][""frodo""]""neo""없음없음따라서 ""muzi""는 처리 결과 메일을 2회, ""frodo""와 ""apeach""는 각각 처리 결과 메일을 1회 받게 됩니다.이용자의 ID가 담긴 문자열 배열id_list, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열report, 정지 기준이 되는 신고 횟수k가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항2 ≤id_list의 길이 ≤ 1,0001 ≤id_list의 원소 길이 ≤ 10id_list의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다.id_list에는 같은 아이디가 중복해서 들어있지 않습니다.1 ≤report의 길이 ≤ 200,0003 ≤report의 원소 길이 ≤ 21report의 원소는 ""이용자id 신고한id""형태의 문자열입니다.예를 들어 ""muzi frodo""의 경우 ""muzi""가 ""frodo""를 신고했다는 의미입니다.id는 알파벳 소문자로만 이루어져 있습니다.이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다.자기 자신을 신고하는 경우는 없습니다.1 ≤k≤ 200,k는 자연수입니다.return 하는 배열은id_list에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다.입출력 예id_listreportkresult[""muzi"", ""frodo"", ""apeach"", ""neo""][""muzi frodo"",""apeach frodo"",""frodo neo"",""muzi neo"",""apeach muzi""]2[2,1,1,0][""con"", ""ryan""][""ryan con"", ""ryan con"", ""ryan con"", ""ryan con""]3[0,0]입출력 예 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2""ryan""이 ""con""을 4번 신고했으나, 주어진 조건에 따라 한 유저가 같은 유저를 여러 번 신고한 경우는 신고 횟수 1회로 처리합니다. 따라서 ""con""은 1회 신고당했습니다. 3번 이상 신고당한 이용자는 없으며, ""con""과 ""ryan""은 결과 메일을 받지 않습니다. 따라서 [0, 0]을 return 합니다.제한시간 안내정확성 테스트 : 10초",1
59,매출 하락 최소화,"유통전문회사카카오상사의 오너인제이지는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인프로도에게 회사의 경영을 부탁하였습니다.""카카오상사""는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다.그림의 조직도는 다음과 같이 설명할 수 있습니다.그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다.원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는직원번호이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는해당 직원의 하루평균 매출액을 나타냅니다. 위 그림에서1번직원은 14원을,9번직원은 28원의 하루평균 매출액을 기록하고 있습니다.CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다.3-1. 직원번호1번은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다.3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다.3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다.  예를들어10번직원은D팀의 팀장이면서 동시에5번직원이 팀장으로 있는C팀에 속한 팀원입니다.3-4.5번, 9번, 10번직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다.3-5.2번, 3번, 4번, 6번, 7번, 8번직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다.3-6.1번직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다.3-7. 그림의 조직도에는A, B, C, D총 4개의 팀이 존재하며, 각각1번, 9번, 5번, 10번직원이 팀장 직위를 담당하게 됩니다.""제이지""는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다.워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로모든 팀은 최소 1명 이상의 직원을 워크숍에 참석시켜야 합니다.워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다.위 그림의 조직도에서 회색으로 색칠된1번, 7번, 10번직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은44(14+13+17)원입니다.10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다.[문제]직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의팀장-팀원의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요.[제한사항]sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다.sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며,1번직원부터 직원번호 순서대로 주어집니다.sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다.links 배열의 크기는sales 배열의 크기 - 1입니다. 즉, 전체 직원 수보다 1이 작습니다.links 배열의 각 원소는 [a, b] 형식입니다.a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다.1 ≤a≤sales 배열의 크기입니다.2 ≤b≤sales 배열의 크기입니다.직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다.links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다.정답으로 return 되는 값은 231- 1 이하인 자연수임이 보장됩니다.[입출력 예]saleslinksresult[14, 17, 15, 18, 19, 14, 13, 16, 28, 17][[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]]44[5, 6, 5, 3, 4][[2,3], [1,4], [2,5], [1,2]]6[5, 6, 5, 1, 4][[2,3], [1,4], [2,5], [1,2]]5[10, 10, 1, 1][[3,2], [4,3], [1,4]]2입출력 예에 대한 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2직원번호가 2인 직원 한 명을 워크숍에 참석시키는 것이 최선이며, 2번 직원의 하루평균 매출액은 6원입니다. 따라서 6을 return 해주어야 합니다.입출력 예 #3직원번호가 4, 5인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 4번, 5번 직원의 하루평균 매출액의 합은 5(1+4)원 입니다. 따라서 5를 return 해주어야 합니다.입출력 예 #4직원번호가 3, 4인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 3번, 4번 직원의 하루평균 매출액의 합은 2(1+1)원 입니다. 따라서 2를 return 해주어야 합니다.",1
60,카드 짝 맞추기,"게임 개발자인베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다.게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여4 x 4크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다.유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다.게임에서 카드를 선택하는 방법은 다음과 같습니다.카드는커서를 이용해서 선택할 수 있습니다.커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 ""굵고 빨간 테두리 상자""를 의미합니다.커서는 [Ctrl] 키와 방향키에 의해 이동되며 키 조작법은 다음과 같습니다.방향키 ←, ↑, ↓, → 중 하나를 누르면, 커서가 누른 키 방향으로 1칸 이동합니다.[Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다.만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다.커서가 위치한 카드를 뒤집기 위해서는 [Enter] 키를 입력합니다.[Enter] 키를 입력해서 카드를 뒤집었을 때앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다.앞면이 보이는 카드가 2장이 된 경우, 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다.""베로니""는 게임 진행 중 카드의 짝을 맞춰 몇 장 제거된 상태에서 카드 앞면의 그림을 알고 있다면, 남은 카드를 모두 제거하는데 필요한 키 조작 횟수의 최솟값을 구해 보려고 합니다. 키 조작 횟수는 방향키와 [Enter] 키를 누르는 동작을 각각 조작 횟수1로 계산하며, [Ctrl] 키와 방향키를 함께 누르는 동작 또한 조작 횟수1로 계산합니다.다음은 카드가 몇 장 제거된 상태의 게임 화면에서 커서를 이동하는 예시입니다.아래 그림에서 빈 칸은 이미 카드가 제거되어 없어진 칸을 의미하며, 그림이 그려진 칸은 카드 앞 면에 그려진 그림을 나타냅니다.예시에서 커서는 두번째 행, 첫번째 열 위치에서 시작하였습니다.[Enter] 입력, ↓ 이동, [Ctrl]+→ 이동, [Enter] 입력 = 키 조작 4회[Ctrl]+↑ 이동, [Enter] 입력, [Ctrl]+← 이동, [Ctrl]+↓ 이동, [Enter] 입력 = 키 조작 5회[Ctrl]+→ 이동, [Enter] 입력, [Ctrl]+↑ 이동, [Ctrl]+← 이동, [Enter] 입력 = 키 조작 5회위와 같은 방법으로 커서를 이동하여 카드를 선택하고 그림을 맞추어 카드를 모두 제거하기 위해서는 총 14번(방향 이동 8번, [Enter] 키 입력 6번)의 키 조작 횟수가 필요합니다.[문제]현재 카드가 놓인 상태를 나타내는 2차원 배열 board와 커서의 처음 위치 r, c가 매개변수로 주어질 때, 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.[제한사항]board는 4 x 4 크기의 2차원 배열입니다.board 배열의 각 원소는 0 이상 6 이하인 자연수입니다.0은 카드가 제거된 빈 칸을 나타냅니다.1 부터 6까지의 자연수는 2개씩 들어있으며 같은 숫자는 같은 그림의 카드를 의미합니다.뒤집을 카드가 없는 경우(board의 모든 원소가 0인 경우)는 입력으로 주어지지 않습니다.r은 커서의 최초 세로(행) 위치를 의미합니다.c는 커서의 최초 가로(열) 위치를 의미합니다.r과 c는 0 이상 3 이하인 정수입니다.게임 화면의 좌측 상단이 (0, 0), 우측 하단이 (3, 3) 입니다.[입출력 예]boardrcresult[[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]]1014[[3,0,0,2],[0,0,1,0],[0,1,0,0],[2,0,0,3]]0116입출력 예에 대한 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2입력으로 주어진 게임 화면은 아래 그림과 같습니다.위 게임 화면에서 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값은 16번 입니다.",1
61,광고 삽입,"카카오TV에서 유명한 크리에이터로 활동 중인죠르디는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 ""죠르디""는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이 가장 많이 보는 구간에 공익광고를 넣으려고 합니다. ""죠르디""는 시청자들이 해당 동영상의 어떤 구간을 재생했는 지 알 수 있는 재생구간 기록을 구했고, 해당 기록을 바탕으로 공익광고가 삽입될 최적의 위치를 고를 수 있었습니다.참고로 광고는 재생 중인 동영상의 오른쪽 아래에서 원래 영상과동시에 재생되는PIP(Picture in Picture) 형태로 제공됩니다.다음은 ""죠르디""가 공익광고가 삽입될 최적의 위치를 고르는 과정을 그림으로 설명한 것입니다.그림의 파란색 선은 광고를 검토 중인 ""죠르디"" 동영상의 전체 재생 구간을 나타냅니다.위 그림에서, ""죠르디"" 동영상의 총 재생시간은02시간 03분 55초입니다.그림의 검은색 선들은 각 시청자들이 ""죠르디""의 동영상을 재생한 구간의 위치를 표시하고 있습니다.검은색 선의 가운데 숫자는 각 재생 기록을 구분하는 ID를 나타냅니다.검은색 선에 표기된 왼쪽 끝 숫자와 오른쪽 끝 숫자는 시청자들이 재생한 동영상 구간의 시작 시각과 종료 시각을 나타냅니다.위 그림에서, 3번 재생 기록은00시 25분 50초부터00시 48분 29초까지 총00시간 22분 39초동안 죠르디의 동영상을 재생했습니다.1위 그림에서, 1번 재생 기록은01시 20분 15초부터01시 45분 14초까지 총00시간 24분 59초동안 죠르디의 동영상을 재생했습니다.그림의 빨간색 선은 ""죠르디""가 선택한 최적의 공익광고 위치를 나타냅니다.만약 공익광고의 재생시간이00시간 14분 15초라면, 위의 그림처럼01시 30분 59초부터01시 45분 14초까지 공익광고를 삽입하는 것이 가장 좋습니다. 이 구간을 시청한 시청자들의 누적 재생시간이 가장 크기 때문입니다.01시 30분 59초부터01시 45분 14초까지의 누적 재생시간은 다음과 같이 계산됩니다.01시 30분 59초부터01시 37분 44초까지 : 4번, 1번 재생 기록이 두차례 있으므로 재생시간의 합은00시간 06분 45초X 2 =00시간 13분 30초01시 37분 44초부터01시 45분 14초까지 : 4번, 1번, 5번 재생 기록이 세차례 있으므로 재생시간의 합은00시간 07분 30초X 3 =00시간 22분 30초따라서, 이 구간 시청자들의 누적 재생시간은00시간 13분 30초+00시간 22분 30초=00시간 36분 00초입니다.[문제]""죠르디""의 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time, 시청자들이 해당 동영상을 재생했던 구간 정보 logs가 매개변수로 주어질 때, 시청자들의 누적 재생시간이 가장 많이 나오는 곳에 공익광고를 삽입하려고 합니다. 이때, 공익광고가 들어갈시작 시각을 구해서 return 하도록 solution 함수를 완성해주세요. 만약, 시청자들의 누적 재생시간이 가장 많은 곳이 여러 곳이라면, 그 중에서가장 빠른 시작 시각을 return 하도록 합니다.[제한사항]play_time, adv_time은 길이 8로 고정된 문자열입니다.play_time, adv_time은HH:MM:SS형식이며,00:00:01이상99:59:59이하입니다.즉, 동영상 재생시간과 공익광고 재생시간은00시간 00분 01초이상99시간 59분 59초이하입니다.공익광고 재생시간은 동영상 재생시간보다 짧거나 같게 주어집니다.logs는 크기가 1 이상 300,000 이하인 문자열 배열입니다.logs 배열의 각 원소는 시청자의 재생 구간을 나타냅니다.logs 배열의 각 원소는 길이가 17로 고정된 문자열입니다.logs 배열의 각 원소는H1:M1:S1-H2:M2:S2형식입니다.H1:M1:S1은 동영상이 시작된 시각,H2:M2:S2는 동영상이 종료된 시각을 나타냅니다.H1:M1:S1는H2:M2:S2보다 1초 이상 이전 시각으로 주어집니다.H1:M1:S1와H2:M2:S2는 play_time 이내의 시각입니다.시간을 나타내는HH, H1, H2의 범위는 00~99, 분을 나타내는MM, M1, M2의 범위는  00~59, 초를 나타내는SS, S1, S2의 범위는 00~59까지 사용됩니다. 잘못된 시각은 입력으로 주어지지 않습니다. (예:04:60:24,11:12:78,123:12:45등)return 값의 형식공익광고를 삽입할 시각을HH:MM:SS형식의 8자리 문자열로 반환합니다.[입출력 예]play_timeadv_timelogsresult""02:03:55""""00:14:15""[""01:20:15-01:45:14"", ""00:40:31-01:00:00"", ""00:25:50-00:48:29"", ""01:30:59-01:53:29"", ""01:37:44-02:02:30""]""01:30:59""""99:59:59""""25:00:00""[""69:59:59-89:59:59"", ""01:00:00-21:00:00"", ""79:59:59-99:59:59"", ""11:00:00-31:00:00""]""01:00:00""""50:00:00""""50:00:00""[""15:36:51-38:21:49"", ""10:14:18-15:36:51"", ""38:21:49-42:51:45""]""00:00:00""입출력 예에 대한 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #201:00:00에 공익광고를 삽입하면26:00:00까지 재생되며, 이곳이 가장 좋은 위치입니다. 이 구간의 시청자 누적 재생시간은 다음과 같습니다.01:00:00-11:00:00: 해당 구간이 1회(2번 기록) 재생되었으므로 누적 재생시간은10시간 00분 00초입니다.11:00:00-21:00:00: 해당 구간이 2회(2번, 4번 기록) 재생되었으므로 누적 재생시간은20시간 00분 00초입니다.21:00:00-26:00:00: 해당 구간이 1회(4번 기록) 재생되었으므로 누적 재생시간은05시간 00분 00초입니다.따라서, 이 구간의 시청자 누적 재생시간은10시간 00분 00초+20시간 00분 00초+05시간 00분 00초=35시간 00분 00초입니다.초록색으로 표시된 구간(69:59:59-94:59:59)에 광고를 삽입해도 동일한 결과를 얻을 수 있으나,01:00:00이69:59:59보다 빠른 시각이므로,""01:00:00""을 return 합니다.입출력 예 #3동영상 재생시간과 공익광고 재생시간이 같으므로, 삽입할 수 있는 위치는 맨 처음(00:00:00)이 유일합니다.동영상 재생시간 = 재생이 종료된 시각 - 재생이 시작된 시각(예를 들어,00시 00분 01초부터00시 00분 10초까지 동영상이 재생되었다면, 동영상 재생시간은9초입니다.)↩",1
62,합승 택시 요금,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. ""무지""는 자신이 택시를 이용할 때 동료인어피치역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. ""무지""는 ""어피치""와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 ""어피치""에게 합승을 제안해 보려고 합니다.위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다.그림에서A와B두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다.A의 집은 6번 지점에 있으며B의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다.그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다.지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다.지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다.간선은 편의 상 직선으로 표시되어 있습니다.위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은10원으로 동일하며 이동 방향에 따라 달라지지 않습니다.예상되는 최저 택시요금은 다음과 같이 계산됩니다.4→1→5 :A,B가 합승하여 택시를 이용합니다. 예상 택시요금은10 + 24 = 34원 입니다.5→6 :A가 혼자 택시를 이용합니다. 예상 택시요금은2원 입니다.5→3→2 :B가 혼자 택시를 이용합니다. 예상 택시요금은24 + 22 = 46원 입니다.A,B모두 귀가 완료까지 예상되는 최저 택시요금은34 + 2 + 46 = 82원 입니다.[문제]지점의 개수 n, 출발지점을 나타내는 s,A의 도착지점을 나타내는 a,B의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때,A,B두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요.만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다.[제한사항]지점갯수 n은 3 이상 200 이하인 자연수입니다.지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.즉, 출발지점,A의 도착지점,B의 도착지점은 서로 겹치지 않습니다.fares는 2차원 정수 배열입니다.fares 배열의 크기는 2 이상n x (n-1) / 2이하입니다.예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15)fares 배열의 각 행은 [c, d, f] 형태입니다.c지점과 d지점 사이의 예상 택시요금이f원이라는 뜻입니다.지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.요금 f는 1 이상 100,000 이하인 자연수입니다.fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.[입출력 예]nsabfaresresult6462[[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]827341[[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]]146456[[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]]18입출력 예에 대한 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2합승을 하지 않고,B는3→2→1,A는3→6→4경로로 각자 택시를 타고 가는 것이 최저 예상 택시요금입니다.따라서 최저 예상 택시요금은(3 + 6) + (1 + 4) = 14원 입니다.입출력 예 #3A와B가4→6구간을 합승하고B가 6번 지점에서 내린 후,A가6→5` 구간을 혼자 타고 가는 것이 최저 예상 택시요금입니다.따라서 최저 예상 택시요금은7 + 11 = 18원 입니다.",1
63,순위 검색,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.인재영입팀에 근무하고 있는니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.* [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?[문제]지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.[제한사항]info 배열의 크기는 1 이상 50,000 이하입니다.info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 ""개발언어 직군 경력 소울푸드 점수"" 형식입니다.개발언어는 cpp, java, python 중 하나입니다.직군은 backend, frontend 중 하나입니다.경력은 junior, senior 중 하나입니다.소울푸드는 chicken, pizza 중 하나입니다.점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.query 배열의 크기는 1 이상 100,000 이하입니다.query의 각 문자열은 ""[조건] X"" 형식입니다.[조건]은 ""개발언어 and 직군 and 경력 and 소울푸드"" 형식의 문자열입니다.언어는 cpp, java, python, - 중 하나입니다.직군은 backend, frontend, - 중 하나입니다.경력은 junior, senior, - 중 하나입니다.소울푸드는 chicken, pizza, - 중 하나입니다.'-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다.X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.예를 들면, ""cpp and - and senior and pizza 500""은 ""cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?""를 의미합니다.[입출력 예]infoqueryresult[""java backend junior pizza 150"",""python frontend senior chicken 210"",""python frontend senior chicken 150"",""cpp backend senior pizza 260"",""java backend junior chicken 80"",""python backend senior chicken 50""][""java and backend and junior and pizza 100"",""python and frontend and senior and chicken 200"",""cpp and - and senior and pizza 250"",""- and backend and senior and - 150"",""- and - and - and chicken 100"",""- and - and - and - 150""][1,1,1,1,2,4]입출력 예에 대한 설명지원자 정보를 표로 나타내면 다음과 같습니다.언어직군경력소울 푸드점수javabackendjuniorpizza150pythonfrontendseniorchicken210pythonfrontendseniorchicken150cppbackendseniorpizza260javabackendjuniorchicken80pythonbackendseniorchicken50""java and backend and junior and pizza 100"": java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.""python and frontend and senior and chicken 200"": python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.""cpp and - and senior and pizza 250"": cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.""- and backend and senior and - 150"": backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.""- and - and - and chicken 100"": 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.""- and - and - and - 150"": 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.",1
64,메뉴 리뉴얼,"레스토랑을 운영하던스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 ""스카피""는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다.예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.)손님 번호주문한 단품메뉴 조합1번 손님A, B, C, F, G2번 손님A, C3번 손님C, D, E4번 손님A, C, D, E5번 손님B, C, F, G6번 손님A, C, D, E, H가장 많이 함께 주문된 단품메뉴 조합에 따라 ""스카피""가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다.코스 종류메뉴 구성설명요리 2개 코스A, C1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다.요리 3개 코스C, D, E3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다.요리 4개 코스B, C, F, G1번, 5번 손님으로부터 총 2번 주문됐습니다.요리 4개 코스A, C, D, E4번, 6번 손님으로부터 총 2번 주문됐습니다.[문제]각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, ""스카피""가추가하고 싶어하는코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, ""스카피""가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.[제한사항]orders 배열의 크기는 2 이상 20 이하입니다.orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.각 문자열은 알파벳 대문자로만 이루어져 있습니다.각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.course 배열의 크기는 1 이상 10 이하입니다.course 배열의 각 원소는 2 이상 10 이하인 자연수가오름차순으로 정렬되어 있습니다.course 배열에는 같은 값이 중복해서 들어있지 않습니다.정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로오름차순정렬해서 return 해주세요.배열의 각 원소에 저장된 문자열 또한 알파벳오름차순으로 정렬되어야 합니다.만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.[입출력 예]orderscourseresult[""ABCFG"", ""AC"", ""CDE"", ""ACDE"", ""BCFG"", ""ACDEH""][2,3,4][""AC"", ""ACDE"", ""BCFG"", ""CDE""][""ABCDE"", ""AB"", ""CD"", ""ADE"", ""XYZ"", ""XYZ"", ""ACD""][2,3,5][""ACD"", ""AD"", ""ADE"", ""CD"", ""XYZ""][""XYZ"", ""XWY"", ""WXA""][2,3,4][""WX"", ""XY""]입출력 예에 대한 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다.입출력 예 #3WX가 두 번, XY가 두 번 주문됐습니다.3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.",1
65,신규 아이디 추천,"카카오에 입사한 신입 개발자네오는 ""카카오계정개발팀""에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. ""네오""에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.다음은 카카오 아이디의 규칙입니다.아이디의 길이는 3자 이상 15자 이하여야 합니다.아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.""네오""는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.신규 유저가 입력한 아이디가new_id라고 한다면,1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.
2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.
3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.
4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.
5단계 new_id가 빈 문자열이라면, new_id에 ""a""를 대입합니다.
6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.
     만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.
7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.예를 들어, new_id 값이 ""...!@BaT#*..y.abcdefghijklm"" 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다.""...!@BaT#*..y.abcdefghijklm""→""...!@bat#*..y.abcdefghijklm""2단계 '!', '@', '#', '*' 문자가 제거되었습니다.""...!@bat#*..y.abcdefghijklm""→""...bat..y.abcdefghijklm""3단계 '...'와 '..' 가 '.'로 바뀌었습니다.""...bat..y.abcdefghijklm""→"".bat.y.abcdefghijklm""4단계 아이디의 처음에 위치한 '.'가 제거되었습니다."".bat.y.abcdefghijklm""→""bat.y.abcdefghijklm""5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.""bat.y.abcdefghijklm""→""bat.y.abcdefghijklm""6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.""bat.y.abcdefghijklm""→""bat.y.abcdefghi""7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.""bat.y.abcdefghi""→""bat.y.abcdefghi""따라서 신규 유저가 입력한 new_id가 ""...!@BaT#*..y.abcdefghijklm""일 때, 네오의 프로그램이 추천하는 새로운 아이디는 ""bat.y.abcdefghi"" 입니다.[문제]신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, ""네오""가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.[제한사항]new_id는 길이 1 이상 1,000 이하인 문자열입니다.new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.new_id에 나타날 수 있는 특수문자는-_.~!@#$%^&*()=+[{]}:?,<>/로 한정됩니다.[입출력 예]nonew_idresult예1""...!@BaT#*..y.abcdefghijklm""""bat.y.abcdefghi""예2""z-+.^.""""z--""예3""=.=""""aaa""예4""123_.def""""123_.def""예5""abcdefghijklmn.p""""abcdefghijklmn""입출력 예에 대한 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #27단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다.1단계 변화 없습니다.2단계""z-+.^.""→""z-..""3단계""z-..""→""z-.""4단계""z-.""→""z-""5단계 변화 없습니다.6단계 변화 없습니다.7단계""z-""→""z--""입출력 예 #37단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다.1단계 변화 없습니다.2단계""=.=""→"".""3단계 변화 없습니다.4단계"".""→""""(new_id가 빈 문자열이 되었습니다.)5단계""""→""a""6단계 변화 없습니다.7단계""a""→""aaa""입출력 예 #41단계에서 7단계까지 거치는 동안 new_id(""123_.def"")는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다.입출력 예 #51단계 변화 없습니다.2단계 변화 없습니다.3단계 변화 없습니다.4단계 변화 없습니다.5단계 변화 없습니다.6단계""abcdefghijklmn.p""→""abcdefghijklmn.""→""abcdefghijklmn""7단계 변화 없습니다.",1
66,블록 이동하기,"로봇개발자""무지""는 한 달 앞으로 다가온 ""카카오배 로봇경진대회""에 출품할로봇을 준비하고 있습니다. 준비 중인 로봇은2 x 1크기의 로봇으로 ""무지""는""0""과""1""로 이루어진N x N크기의 지도에서2 x 1크기인 로봇을 움직여(N, N)위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를(1, 1)로 하며 지도 내에 표시된 숫자""0""은 빈칸을""1""은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표(1, 1)위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다.로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 위 그림에서 오른쪽으로 한 칸 이동한다면(1, 2), (1, 3)두 칸을 차지하게 되며, 아래로 이동한다면(2, 1), (2, 2)두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도(N, N)위치에 도착하면 됩니다.로봇은 다음과 같이 조건에 따라 회전이 가능합니다.위 그림과 같이 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다.""0""과""1""로 이루어진 지도인 board가 주어질 때, 로봇이(N, N)위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요.제한사항board의 한 변의 길이는 5 이상 100 이하입니다.board의 원소는 0 또는 1입니다.로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다.로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다.입출력 예boardresult[[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]7입출력 예에 대한 설명문제에 주어진 예시와 같습니다.로봇이 오른쪽으로 한 칸 이동 후, (1, 3) 칸을 축으로 반시계 방향으로 90도 회전합니다. 다시, 아래쪽으로 3칸 이동하면 로봇은 (4, 3), (5, 3) 두 칸을 차지하게 됩니다. 이제 (5, 3)을 축으로 시계 방향으로 90도 회전 후, 오른쪽으로 한 칸 이동하면 (N, N)에 도착합니다. 따라서 목적지에 도달하기까지 최소 7초가 걸립니다.",1
67,외벽 점검,"레스토랑을 운영하고 있는""스카피""는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.레스토랑의 구조는완전히 동그란 모양이고외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될  수도 있는취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.제한사항n은 1 이상 200 이하인 자연수입니다.weak의 길이는 1 이상 15 이하입니다.서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.weak의 원소는 0 이상 n - 1 이하인 정수입니다.dist의 길이는 1 이상 8 이하입니다.dist의 원소는 1 이상 100 이하인 자연수입니다.친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.입출력 예nweakdistresult12[1, 5, 6, 10][1, 2, 3, 4]212[1, 3, 4, 9, 10][3, 5, 7]1입출력 예에 대한 설명입출력 예 #1원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.친구들을 투입하는 예시 중 하나는 다음과 같습니다.4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다.2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다.그 외에 여러 방법들이 있지만, 두 명보다 적은  친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다.입출력 예 #2원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.7m를 이동할 수 있는 친구가 4m 지점에서 출발해 반시계 방향으로 점검을 돌면 모든 취약 지점을 점검할 수 있습니다. 따라서 친구를 최소 한 명 투입하면 됩니다.",1
68,기둥과 보 설치,"빙하가 깨지면서 스노우타운에 떠내려 온""죠르디""는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. ""죠르디""는기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.프로그램은2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다.기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.단, 바닥은 벽면의 맨 아래 지면을 말합니다.2차원 벽면은n x n크기 정사각 격자 형태이며, 각 격자는1 x 1크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다.예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다.(1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다.(2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다.(5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다.(4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다.만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다.벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.제한사항n은 5 이상 100 이하인 자연수입니다.build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.build_frame의 가로(열) 길이는 4입니다.build_frame의 원소는 [x, y, a, b]형태입니다.x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.바닥에 보를 설치 하는 경우는 없습니다.구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.return 하는 배열의 원소는 [x, y, a] 형식입니다.x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.입출력 예nbuild_frameresult5[[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]][[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]]5[[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]][[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]]입출력 예에 대한 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #2여덟 번째 작업을 수행 후 아래와 같은 구조물 만들어집니다.아홉 번째 작업의 경우, (1, 1)에서 오른쪽에 있는 보를 삭제하면 (2, 1)에서 오른쪽에 있는 보는 조건을 만족하지 않으므로 무시됩니다.열 번째 작업의 경우, (2, 2)에서 위쪽 방향으로 기둥을 세울 경우 조건을 만족하지 않으므로 무시됩니다.",1
69,가사 검색,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]친구들로부터 천재 프로그래머로 불리는""프로도""는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다.그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어""fro??""는""frodo"",""front"",""frost""등에 매치되지만""frame"",""frozen""에는 매치되지 않습니다.가사에 사용된 모든 단어들이 담긴 배열words와 찾고자 하는 키워드가 담긴 배열queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지순서대로배열에 담아 반환하도록solution함수를 완성해 주세요.가사 단어 제한사항words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다.각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다.가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고words에는 하나로만 제공됩니다.각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.검색 키워드 제한사항queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다.각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다.검색 키워드는 중복될 수도 있습니다.각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인'?'로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.검색 키워드는 와일드카드 문자인'?'가 하나 이상 포함돼 있으며,'?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다.예를 들어""??odo"",""fro??"",""?????""는 가능한 키워드입니다.반면에""frodo""('?'가 없음),""fr?do""('?'가 중간에 있음),""?ro??""('?'가 양쪽에 있음)는 불가능한 키워드입니다.입출력 예wordsqueriesresult[""frodo"", ""front"", ""frost"", ""frozen"", ""frame"", ""kakao""][""fro??"", ""????o"", ""fr???"", ""fro???"", ""pro?""][3, 2, 4, 1, 0]입출력 예에 대한 설명""fro??""는""frodo"",""front"",""frost""에 매치되므로 3입니다.""????o""는""frodo"",""kakao""에 매치되므로 2입니다.""fr???""는""frodo"",""front"",""frost"",""frame""에 매치되므로 4입니다.""fro???""는""frozen""에 매치되므로 1입니다.""pro?""는 매치되는 가사 단어가 없으므로 0 입니다.",1
70,자물쇠와 열쇠,"고고학자인""튜브""는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.잠겨있는 자물쇠는 격자 한 칸의 크기가1 x 1인N x N크기의 정사각 격자 형태이고 특이한 모양의 열쇠는M x M크기인 정사각 격자 형태로 되어 있습니다.자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.제한사항key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.M은 항상 N 이하입니다.key와 lock의 원소는 0 또는 1로 이루어져 있습니다.0은 홈 부분, 1은 돌기 부분을 나타냅니다.입출력 예keylockresult[[0, 0, 0], [1, 0, 0], [0, 1, 1]][[1, 1, 1], [1, 1, 0], [1, 0, 1]]true입출력 예에 대한 설명key를 시계 방향으로 90도 회전하고, 오른쪽으로 한 칸, 아래로 한 칸 이동하면 lock의 홈 부분을 정확히 모두 채울 수 있습니다.",1
71,괄호 변환,"카카오에 신입 개발자로 입사한""콘""은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.수정해야 할 소스 파일이 너무 많아서 고민하던 ""콘""은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다.용어의 정의'('와')'로만 이루어진 문자열이 있을 경우, '(' 의 개수와 ')' 의 개수가 같다면 이를균형잡힌 괄호 문자열이라고 부릅니다.그리고 여기에 '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 이를올바른 괄호 문자열이라고 부릅니다.예를 들어,""(()))(""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이지만 ""올바른 괄호 문자열""은 아닙니다.반면에""(())()""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이면서 동시에 ""올바른 괄호 문자열"" 입니다.'(' 와 ')' 로만 이루어진 문자열 w가 ""균형잡힌 괄호 문자열"" 이라면 다음과 같은 과정을 통해 ""올바른 괄호 문자열""로 변환할 수 있습니다.1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 
2. 문자열 w를 두 ""균형잡힌 괄호 문자열"" u, v로 분리합니다. 단, u는 ""균형잡힌 괄호 문자열""로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 
3. 문자열 u가 ""올바른 괄호 문자열"" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 
  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 
4. 문자열 u가 ""올바른 괄호 문자열""이 아니라면 아래 과정을 수행합니다. 
  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 
  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 
  4-3. ')'를 다시 붙입니다. 
  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 
  4-5. 생성된 문자열을 반환합니다.""균형잡힌 괄호 문자열""p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해""올바른 괄호 문자열""로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.매개변수 설명p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.문자열 p를 이루는 '(' 와 ')' 의 개수는 항상 같습니다.만약 p가 이미 ""올바른 괄호 문자열""이라면 그대로 return 하면 됩니다.입출력 예presult""(()())()""""(()())()"""")(""""()""""()))((()""""()(())()""입출력 예에 대한 설명입출력 예 #1이미 ""올바른 괄호 문자열"" 입니다.입출력 예 #2두 문자열 u, v로 분리합니다.u ="")(""v =""""u가 ""올바른 괄호 문자열""이 아니므로 다음과 같이 새로운 문자열을 만듭니다.v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다.u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면""""이 됩니다.따라서 생성되는 문자열은""(""+""""+"")""+""""이며, 최종적으로""()""로 변환됩니다.입출력 예 #3두 문자열 u, v로 분리합니다.u =""()""v =""))((()""문자열 u가 ""올바른 괄호 문자열""이므로 그대로 두고, v에 대해 재귀적으로 수행합니다.다시 두 문자열 u, v로 분리합니다.u =""))((""v =""()""u가 ""올바른 괄호 문자열""이 아니므로 다음과 같이 새로운 문자열을 만듭니다.v에 대해 1단계부터 재귀적으로 수행하면""()""이 반환됩니다.u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면""()""이 됩니다.따라서 생성되는 문자열은""(""+""()""+"")""+""()""이며, 최종적으로""(())()""를 반환합니다.처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면""()""+""(())()""=""()(())()""가 됩니다.",1
72,문자열 압축,"데이터 처리 전문가가 되고 싶은""어피치""는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.간단한 예로 ""aabbaccc""의 경우 ""2a2ba3c""(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, ""abcabcdede""와 같은 문자열은 전혀 압축되지 않습니다. ""어피치""는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.예를 들어, ""ababcdcdababcdcd""의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 ""2ab2cd2ab2cd""로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 ""2ababcdcd""로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.다른 예로, ""abcabcdede""와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 ""abcabc2de""가 되지만, 3개 단위로 자른다면 ""2abcdede""가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.제한사항s의 길이는 1 이상 1,000 이하입니다.s는 알파벳 소문자로만 이루어져 있습니다.입출력 예sresult""aabbaccc""7""ababcdcdababcdcd""9""abcabcdede""8""abcabcabcabcdededededede""14""xababcdcdababcdcd""17입출력 예에 대한 설명입출력 예 #1문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #2문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #3문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #4문자열을 2개 단위로 자르면 ""abcabcabcabc6de"" 가 됩니다.문자열을 3개 단위로 자르면 ""4abcdededededede"" 가 됩니다.문자열을 4개 단위로 자르면 ""abcabcabcabc3dede"" 가 됩니다.문자열을 6개 단위로 자를 경우 ""2abcabc2dedede""가 되며, 이때의 길이가 14로 가장 짧습니다.입출력 예 #5문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.따라서 주어진 문자열을 x / ababcdcd  /  ababcdcd 로 자르는 것은 불가능 합니다.이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.",1
73,블록 게임,"블록게임프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다.이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다.프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자.게임규칙아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다.1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다.플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다.이때, 검은 블록과 기존에 놓인 블록을 합해속이 꽉 채워진직사각형을 만들 수 있다면 그 블록을 없앨 수 있다.예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다.빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다.그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다.따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다.보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라.제한사항board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다.N은4이상50이하다.board의 각 행의 원소는0이상200이하의 자연수이다.0 은 빈 칸을 나타낸다.board에 놓여있는 각 블록은 숫자를 이용해 표현한다.잘못된 블록 모양이 주어지는 경우는 없다.모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현된다.예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다.입출력 예boardresult[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]]2입출력 예 설명입출력 예 #1문제에 주어진 예시와 같음",1
74,매칭 점수,"매칭 점수프렌즈 대학교 조교였던 제이지는 허드렛일만 시키는 네오 학과장님의 마수에서 벗어나, 카카오에 입사하게 되었다.평소에 관심있어하던 검색에 마침 결원이 발생하여, 검색개발팀에 편입될 수 있었고, 대망의 첫 프로젝트를 맡게 되었다.그 프로젝트는 검색어에 가장 잘 맞는 웹페이지를 보여주기 위해 아래와 같은 규칙으로 검색어에 대한 웹페이지의 매칭점수를 계산 하는 것이었다.한 웹페이지에 대해서 기본점수, 외부 링크 수, 링크점수, 그리고 매칭점수를 구할 수 있다.한 웹페이지의 기본점수는 해당 웹페이지의 텍스트 중, 검색어가 등장하는 횟수이다. (대소문자 무시)한 웹페이지의 외부 링크 수는 해당 웹페이지에서 다른 외부 페이지로 연결된 링크의 개수이다.한 웹페이지의 링크점수는 해당 웹페이지로 링크가 걸린 다른 웹페이지의 기본점수 ÷ 외부 링크 수의 총합이다.한 웹페이지의 매칭점수는 기본점수와 링크점수의 합으로 계산한다.예를 들어, 다음과 같이 A, B, C 세 개의 웹페이지가 있고, 검색어가 hi라고 하자.이때 A 웹페이지의 매칭점수는 다음과 같이 계산할 수 있다.기본 점수는 각 웹페이지에서 hi가 등장한 횟수이다.A,B,C 웹페이지의 기본점수는 각각 1점, 4점, 9점이다.외부 링크수는 다른 웹페이지로 링크가 걸린 개수이다.A,B,C 웹페이지의 외부 링크 수는 각각 1점, 2점, 3점이다.A 웹페이지로 링크가 걸린 페이지는 B와 C가 있다.A 웹페이지의 링크점수는 B의 링크점수 2점(4 ÷ 2)과 C의 링크점수 3점(9 ÷ 3)을 더한 5점이 된다.그러므로, A 웹페이지의 매칭점수는 기본점수 1점 + 링크점수 5점 = 6점이 된다.검색어 word와 웹페이지의 HTML 목록인 pages가 주어졌을 때, 매칭점수가 가장 높은 웹페이지의 index를 구하라. 만약 그런 웹페이지가 여러 개라면 그중 번호가 가장 작은 것을 구하라.제한사항pages는 HTML 형식의 웹페이지가 문자열 형태로 들어있는 배열이고, 길이는1이상20이하이다.한 웹페이지 문자열의 길이는1이상1,500이하이다.웹페이지의 index는 pages 배열의 index와 같으며 0부터 시작한다.한 웹페이지의 url은 HTML의태그 내에태그의 값으로 주어진다.예를들어, 아래와 같은 meta tag가 있으면 이 웹페이지의 url은https://careers.kakao.com/index이다.<meta property=""og:url"" content=""https://careers.kakao.com/index"" />한 웹페이지에서 모든 외부 링크는<a href=""https://careers.kakao.com/index"">의 형태를 가진다.<a>내에 다른 attribute가 주어지는 경우는 없으며 항상 href로 연결할 사이트의 url만 포함된다.위의 경우에서 해당 웹페이지는https://careers.kakao.com/index로 외부링크를 가지고 있다고 볼 수 있다.모든 url은https://로만 시작한다.검색어 word는 하나의 영어 단어로만 주어지며 알파벳 소문자와 대문자로만 이루어져 있다.word의 길이는1이상12이하이다.검색어를 찾을 때, 대소문자 구분은 무시하고 찾는다.예를들어 검색어가 blind일 때, HTML 내에 Blind라는 단어가 있거나, BLIND라는 단어가 있으면 두 경우 모두 해당된다.검색어는 단어 단위로 비교하며, 단어와 완전히 일치하는 경우에만 기본 점수에 반영한다.단어는 알파벳을 제외한 다른 모든 문자로 구분한다.예를들어 검색어가 ""aba"" 일 때, ""abab abababa""는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다.만약 검색어가 ""aba"" 라면, ""aba@aba aba""는 단어 단위로 세개가 일치하므로, 기본 점수는 3점이다.결과를 돌려줄때, 동일한 매칭점수를 가진 웹페이지가 여러 개라면 그중 index 번호가 가장 작은 것를 리턴한다즉, 웹페이지가 세개이고, 각각 매칭점수가 3,1,3 이라면 제일 적은 index 번호인 0을 리턴하면 된다.입출력 예 #1word : blindpages :[""<htmllang=\""ko\""xml:lang=\""ko\""xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n<metacharset=\""utf-8\"">\n<metaproperty=\""og:url\""content=\""https://a.com\""/>\n</head>\n<body>\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \n<ahref=\""https://b.com\"">Link to b</a>\n</body>\n</html>"", ""<htmllang=\""ko\""xml:lang=\""ko\""xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n<metacharset=\""utf-8\"">\n<metaproperty=\""og:url\""content=\""https://b.com\""/>\n</head>\n<body>\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \n<ahref=\""https://a.com\"">Link to a</a>\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\n<ahref=\""https://c.com\"">Link to c</a>\n</body>\n</html>"", ""<htmllang=\""ko\""xml:lang=\""ko\""xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n<metacharset=\""utf-8\"">\n<metaproperty=\""og:url\""content=\""https://c.com\""/>\n</head>\n<body>\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\n<ahref=\""https://a.com\"">Link to a</a>\n</body>\n</html>""]pages는 다음과 같이 3개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다.<html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
  <meta charset=""utf-8"">
  <meta property=""og:url"" content=""https://a.com""/>
</head>
<body>
Blind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. 
<a href=""https://b.com""> Link to b </a>
</body>
</html><html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
  <meta charset=""utf-8"">
  <meta property=""og:url"" content=""https://b.com""/>
</head>
<body>
Suspendisse potenti. Vivamus venenatis tellus non turpis bibendum, 
<a href=""https://a.com""> Link to a </a>
blind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.
<a href=""https://c.com""> Link to c </a>
</body>
</html><html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
  <meta charset=""utf-8"">
  <meta property=""og:url"" content=""https://c.com""/>
</head>
<body>
Ut condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind
<a href=""https://a.com""> Link to a </a>
</body>
</html>위의 예를 가지고 각각의 점수를 계산해보자.기본점수 및 외부 링크수는 아래와 같다.a.com의 기본점수는 3, 외부 링크 수는 1개b.com의 기본점수는 1, 외부 링크 수는 2개c.com의 기본점수는 1, 외부 링크 수는 1개링크점수는 아래와 같다.a.com의 링크점수는 b.com으로부터 0.5점, c.com으로부터 1점b.com의 링크점수는 a.com으로부터 3점c.com의 링크점수는 b.com으로부터 0.5점각 웹 페이지의 매칭 점수는 다음과 같다.a.com : 4.5 점b.com : 4 점c.com : 1.5 점따라서 매칭점수가 제일 높은 첫번째 웹 페이지의 index인 0을 리턴 하면 된다.입출력 예 #2word : Muzipages :[""<htmllang=\""ko\""xml:lang=\""ko\""xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n<metacharset=\""utf-8\"">\n<metaproperty=\""og:url\""content=\""https://careers.kakao.com/interview/list\""/>\n</head>\n<body>\n<ahref=\""https://programmers.co.kr/learn/courses/4673\""></a>#!MuziMuzi!)jayg07con&&\n\n</body>\n</html>"", ""<htmllang=\""ko\""xml:lang=\""ko\""xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n<metacharset=\""utf-8\"">\n<metaproperty=\""og:url\""content=\""https://www.kakaocorp.com\""/>\n</head>\n<body>\ncon%\tmuzI92apeach&2<ahref=\""https://hashcode.co.kr/tos\""></a>\n\n\t^\n</body>\n</html>""]pages는 다음과 같이 2개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다.<html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
  <meta charset=""utf-8"">
  <meta property=""og:url"" content=""https://careers.kakao.com/interview/list""/>
</head>
<body>
<a href=""https://programmers.co.kr/learn/courses/4673""></a>#!MuziMuzi!)jayg07con&&

</body>
</html><html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
  <meta charset=""utf-8"">
  <meta property=""og:url"" content=""https://www.kakaocorp.com""/>
</head>
<body>
con%    muzI92apeach&2<a href=""https://hashcode.co.kr/tos""></a>

    ^
</body>
</html>기본점수 및 외부 링크수는 아래와 같다.careers.kakao.com/interview/list의 기본점수는 0, 외부 링크 수는 1개www.kakaocorp.com의 기본점수는 1, 외부 링크 수는 1개링크점수는 아래와 같다.careers.kakao.com/interview/list의 링크점수는 0점www.kakaocorp.com의 링크점수는 0점각 웹 페이지의 매칭 점수는 다음과 같다.careers.kakao.com/interview/list: 0점www.kakaocorp.com: 1 점따라서 매칭점수가 제일 높은 두번째 웹 페이지의 index인 1을 리턴 하면 된다.",1
75,길 찾기 게임,"길 찾기 게임전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다.내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다.그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다.트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다.모든 노드는 서로 다른 x값을 가진다.같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다.자식 노드의 y 값은 항상 부모 노드보다 작다.임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다.임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.아래 예시를 확인해보자.라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다.전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다.그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.이제 당신이 나설 때가 되었다.곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때,노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.제한사항nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다.nodeinfo의 길이는1이상10,000이하이다.nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다.모든 노드의 좌표 값은0이상100,000이하인 정수이다.트리의 깊이가1,000이하인 경우만 입력으로 주어진다.모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다.입출력 예nodeinforesult[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]][[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]입출력 예 설명입출력 예 #1문제에 주어진 예시와 같다.",1
76,무지의 먹방 라이브,"무지의 먹방 라이브* 효율성 테스트에 부분 점수가 있는 문제입니다.평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.회전판에 먹어야 할 N 개의 음식이 있다.각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.무지는 다음과 같은 방법으로 음식을 섭취한다.무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.제한사항food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.k 는 방송이 중단된 시간을 나타낸다.만약 더 섭취해야 할 음식이 없다면-1을 반환하면 된다.정확성 테스트 제한 사항food_times 의 길이는1이상2,000이하이다.food_times 의 원소는1이상1,000이하의 자연수이다.k는1이상2,000,000이하의 자연수이다.효율성 테스트 제한 사항food_times 의 길이는1이상200,000이하이다.food_times 의 원소는1이상100,000,000이하의 자연수이다.k는1이상2 x  10^13이하의 자연수이다.입출력 예food_timeskresult[3, 1, 2]51입출력 예 설명입출력 예 #10~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.",1
77,후보키,"후보키프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다.그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다.후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다.관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 ""학번""을 가지고 있다. 따라서 ""학번""은 릴레이션의 후보 키가 될 수 있다.그다음 ""이름""에 대해서는 같은 이름(""apeach"")을 사용하는 학생이 있기 때문에, ""이름""은 후보 키가 될 수 없다. 그러나, 만약 [""이름"", ""전공""]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다.물론 [""이름"", ""전공"", ""학년""]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다.따라서, 위의 학생 인적사항의 후보키는 ""학번"", [""이름"", ""전공""] 두 개가 된다.릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라.제한사항relation은 2차원 문자열 배열이다.relation의 컬럼(column)의 길이는1이상8이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다.relation의 로우(row)의 길이는1이상20이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다.relation의 모든 문자열의 길이는1이상8이하이며, 알파벳 소문자와 숫자로만 이루어져 있다.relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.)입출력 예relationresult[[""100"",""ryan"",""music"",""2""],[""200"",""apeach"",""math"",""2""],[""300"",""tube"",""computer"",""3""],[""400"",""con"",""computer"",""4""],[""500"",""muzi"",""music"",""3""],[""600"",""apeach"",""music"",""2""]]2입출력 예 설명입출력 예 #1문제에 주어진 릴레이션과 같으며, 후보 키는 2개이다.",1
78,실패율,"실패율슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.실패율은 다음과 같이 정의한다.스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.제한사항스테이지의 개수 N은1이상500이하의 자연수이다.stages의 길이는1이상200,000이하이다.stages에는1이상N + 1이하의 자연수가 담겨있다.각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.단,N + 1은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은0으로 정의한다.입출력 예Nstagesresult5[2, 1, 2, 6, 2, 4, 3, 3][3,4,2,1,5]4[4,4,4,4,4][4,1,2,3]입출력 예 설명입출력 예 #11번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.1 번 스테이지 실패율 : 1/82번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.2 번 스테이지 실패율 : 3/7마찬가지로 나머지 스테이지의 실패율은 다음과 같다.3 번 스테이지 실패율 : 2/44번 스테이지 실패율 : 1/25번 스테이지 실패율 : 0/1각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.[3,4,2,1,5]입출력 예 #2모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.[4,1,2,3]",1
79,오픈채팅방 ,"오픈채팅방카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.""[닉네임]님이 들어왔습니다.""채팅방에서 누군가 나가면 다음 메시지가 출력된다.""[닉네임]님이 나갔습니다.""채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.채팅방에서 닉네임을 변경한다.닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.예를 들어, 채팅방에 ""Muzi""와 ""Prodo""라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.""Muzi님이 들어왔습니다.""""Prodo님이 들어왔습니다.""채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.""Muzi님이 들어왔습니다.""""Prodo님이 들어왔습니다.""""Muzi님이 나갔습니다.""Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.""Prodo님이 들어왔습니다.""""Prodo님이 들어왔습니다.""""Prodo님이 나갔습니다.""""Prodo님이 들어왔습니다.""채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.""Prodo님이 들어왔습니다.""""Ryan님이 들어왔습니다.""""Prodo님이 나갔습니다.""""Prodo님이 들어왔습니다.""채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.제한사항record는 다음과 같은 문자열이 담긴 배열이며, 길이는1이상100,000이하이다.다음은 record에 담긴 문자열에 대한 설명이다.모든 유저는 [유저 아이디]로 구분한다.[유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - ""Enter [유저 아이디] [닉네임]"" (ex. ""Enter uid1234 Muzi"")[유저 아이디] 사용자가 채팅방에서 퇴장 - ""Leave [유저 아이디]"" (ex. ""Leave uid1234"")[유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - ""Change [유저 아이디] [닉네임]"" (ex. ""Change uid1234 Muzi"")첫 단어는 Enter, Leave, Change 중 하나이다.각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.유저 아이디와 닉네임의 길이는1이상10이하이다.채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.입출력 예recordresult[""Enter uid1234 Muzi"", ""Enter uid4567 Prodo"",""Leave uid1234"",""Enter uid1234 Prodo"",""Change uid4567 Ryan""][""Prodo님이 들어왔습니다."", ""Ryan님이 들어왔습니다."", ""Prodo님이 나갔습니다."", ""Prodo님이 들어왔습니다.""]입출력 예 설명입출력 예 #1문제의 설명과 같다.",1
80,[3차] n진수 게임,"N진수 게임튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.이렇게 게임을 진행할 경우,0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …순으로 숫자를 말하면 된다.한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …순으로 숫자를 말하면 된다.이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.입력 형식진법n,  미리 구할 숫자의 갯수t, 게임에 참가하는 인원m, 튜브의 순서p가 주어진다.2 ≦n≦ 160 ＜t≦ 10002 ≦m≦ 1001 ≦p≦m출력 형식튜브가 말해야 하는 숫자t개를 공백 없이 차례대로 나타낸 문자열. 단,10~15는 각각 대문자A~F로 출력한다.입출력 예제ntmpresult2421""0111""161621""02468ACE11111111""161622""13579BDF01234567""해설 보러가기",1
81,[3차] 파일명 정렬,"파일명 정렬세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다.저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다.버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이 [""img12.png"", ""img10.png"", ""img2.png"", ""img1.png""]일 경우, 일반적인 정렬은 [""img1.png"", ""img10.png"", ""img12.png"", ""img2.png""] 순이 되지만, 숫자 순으로 정렬된 [""img1.png"", ""img2.png"", ""img10.png"", img12.png""] 순이 훨씬 자연스럽다.무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다.소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다.0부터99999사이의 숫자로,00000이나0101등도 가능하다.TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.파일명HEADNUMBERTAILfoo9.txtfoo9.txtfoo010bar020.zipfoo010bar020.zipF-15F-15(빈 문자열)파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다.MUZI와muzi,MuZi는 정렬 시에 같은 순서로 취급된다.파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다.MUZI01.zip과muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.무지를 도와 파일명 정렬 프로그램을 구현하라.입력 형식입력으로 배열files가 주어진다.files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt,MUZI1.txt,muzi001.txt,muzi1.TXT는 함께 입력으로 주어질 수 있다.)출력 형식위 기준에 따라 정렬된 배열을 출력한다.입출력 예제입력: [""img12.png"", ""img10.png"", ""img02.png"", ""img1.png"", ""IMG01.GIF"", ""img2.JPG""]출력: [""img1.png"", ""IMG01.GIF"", ""img02.png"", ""img2.JPG"", ""img10.png"", ""img12.png""]입력: [""F-5 Freedom Fighter"", ""B-50 Superfortress"", ""A-10 Thunderbolt II"", ""F-14 Tomcat""]출력: [""A-10 Thunderbolt II"", ""B-50 Superfortress"", ""F-5 Freedom Fighter"", ""F-14 Tomcat""]해설 보러가기",1
82,[3차] 자동완성,"자동완성포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어,go가 한 번 입력되었다면, 다음 사용자는g만 입력해도go를 추천해주므로o를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.예를 들어, 학습된 단어들이 아래와 같을 때go
gone
guildgo를 찾을 때go를 모두 입력해야 한다.gone을 찾을 때gon까지 입력해야 한다. 
(gon이 입력되기 전까지는go인지gone인지 확신할 수 없다.)guild를 찾을 때는gu까지만 입력하면guild가 완성된다.이 경우 총 입력해야 할 문자의 수는7이다.라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.입력 형식학습과 검색에 사용될 중복 없는 단어N개가 주어진다.모든 단어는 알파벳 소문자로 구성되며 단어의 수N과 단어들의 길이의 총합L의 범위는 다음과 같다.2 <=N<= 100,0002 <=L<= 1,000,000출력 형식단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.입출력 예제wordsresult[""go"",""gone"",""guild""]7[""abc"",""def"",""ghi"",""jklm""]4[""word"",""war"",""warrior"",""world""]15입출력 설명첫 번째 예제는 본문 설명과 같다.두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.세 번째 예제는 총15자를 입력해야 하고 설명은 아래와 같다.word는word모두 입력해야 한다.war는war까지 모두 입력해야 한다.warrior는warr까지만 입력하면 된다.world는worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자)해설 보러가기",1
83,[3차] 압축,"압축신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.LZW 압축은 다음 과정을 거친다.길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.사전에서 현재 입력과 일치하는 가장 긴 문자열w를 찾는다.w에 해당하는 사전의 색인 번호를 출력하고, 입력에서w를 제거한다.입력에서 처리되지 않은 다음 글자가 남아있다면(c),w+c에 해당하는 단어를 사전에 등록한다.단계 2로 돌아간다.압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.색인 번호123...242526단어ABC...XYZ예를 들어 입력으로KAKAO가 들어온다고 하자.현재 사전에는KAKAO의 첫 글자K는 등록되어 있으나, 두 번째 글자까지인KA는 없으므로, 첫 글자K에 해당하는 색인 번호 11을 출력하고, 다음 글자인A를 포함한KA를 사전에 27 번째로 등록한다.두 번째 글자A는 사전에 있으나, 세 번째 글자까지인AK는 사전에 없으므로,A의  색인 번호 1을 출력하고,AK를 사전에 28 번째로 등록한다.세 번째 글자에서 시작하는KA가 사전에 있으므로,KA에 해당하는 색인 번호 27을 출력하고, 다음 글자O를 포함한KAO를 29 번째로 등록한다.마지막으로 처리되지 않은 글자O에 해당하는 색인 번호 15를 출력한다.현재 입력(w)다음 글자(c)출력사전 추가(w+c)KA1127: KAAK128: AKKAO2729: KAOO15이 과정을 거쳐 다섯 글자의 문장KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.입력으로TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다.현재 입력(w)다음 글자(c)출력사전 추가(w+c)TO2027: TOOB1528: OBBE229: BEEO530: EOOR1531: ORRN1832: RNNO1433: NOOT1534: OTTT2035: TTTOB2736: TOBBEO2937: BEOORT3138: ORTTOBE3639: TOBEEOR3040: EORRNO3241: RNOOT34입력 형식입력으로 영문 대문자로만 이뤄진 문자열msg가 주어진다.msg의 길이는 1 글자 이상, 1000 글자 이하이다.출력 형식주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.입출력 예제msganswerKAKAO[11, 1, 27, 15]TOBEORNOTTOBEORTOBEORNOT[20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]ABABABABABABABAB[1, 2, 27, 29, 28, 31, 30]해설 보러가기",1
84,[3차] 방금그곡,"방금그곡라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 '방금그곡' 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다.네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다.  음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.음악이 00:00를 넘겨서까지 재생되는 일은 없다.조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다.입력 형식입력으로 네오가 기억한 멜로디를 담은 문자열m과 방송된 곡의 정보를 담고 있는 배열musicinfos가 주어진다.m은 음1개 이상1439개 이하로 구성되어 있다.musicinfos는100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ','로 구분된 문자열이다.음악의 시작 시각과 끝난 시각은 24시간HH:MM형식이다.음악 제목은 ',' 이외의 출력 가능한 문자로 표현된 길이1이상64이하의 문자열이다.악보 정보는 음1개 이상1439개 이하로 구성되어 있다.출력 형식조건과 일치하는 음악 제목을 출력한다.입출력 예시mmusicinfosanswer""ABCDEFG""[""12:00,12:14,HELLO,CDEFGAB"", ""13:00,13:05,WORLD,ABCDEF""]""HELLO""""CC#BCC#BCC#BCC#B""[""03:00,03:30,FOO,CC#B"", ""04:00,04:08,BAR,CC#BCC#BCC#B""]""FOO""""ABC""[""12:00,12:14,HELLO,C#DEFGAB"", ""13:00,13:05,WORLD,ABCDEF""]""WORLD""설명첫 번째 예시에서 HELLO는 길이가 7분이지만 12:00부터 12:14까지 재생되었으므로 실제로 CDEFGABCDEFGAB로 재생되었고, 이 중에 기억한 멜로디인 ABCDEFG가 들어있다.세 번째 예시에서 HELLO는 C#DEFGABC#DEFGAB로, WORLD는 ABCDE로 재생되었다. HELLO 안에 있는 ABC#은 기억한 멜로디인 ABC와 일치하지 않고, WORLD 안에 있는 ABC가 기억한 멜로디와 일치한다.해설 보러가기",1
85,[1차] 다트 게임,"다트 게임카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.다트 게임은 총 3번의 기회로 구성된다.각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1, 점수2, 점수3)으로 계산된다.옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고)스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고)스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.입력 형식""점수|보너스|[옵션]""으로 이루어진 문자열 3세트.예)1S2D*3T점수는 0에서 10 사이의 정수이다.보너스는 S, D, T 중 하나이다.옵선은 *이나 # 중 하나이며, 없을 수도 있다.출력 형식3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.예) 37입출력 예제예제dartResultanswer설명11S2D*3T3711* 2 + 22* 2 + 3321D2S#10S912+ 21* (-1) + 10131D2S0T312+ 21+ 0341S*2T*3S2311* 2 * 2 + 23* 2 + 3151D#2S*3S512* (-1) * 2 + 21* 2 + 3161T2D3D#-413+ 22+ 32* (-1)71D2S3T*5912+ 21* 2 + 33* 2해설 보러가기",1
86,[1차] 비밀지도,"비밀지도네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.지도는 한 변의 길이가n인 정사각형 배열 형태로, 각 칸은 ""공백""("" "") 또는 ""벽""(""#"") 두 종류로 이루어져 있다.전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 ""지도 1""과 ""지도 2""라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.""지도 1""과 ""지도 2""는 각각 정수 배열로 암호화되어 있다.암호화된 배열은 지도의 각 가로줄에서 벽 부분을1, 공백 부분을0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.입력 형식입력으로 지도의 한 변 크기n과 2개의 정수 배열arr1,arr2가 들어온다.1 ≦n≦ 16arr1,arr2는 길이n인 정수 배열로 주어진다.정수 배열의 각 원소x를 이진수로 변환했을 때의 길이는n이하이다. 즉, 0 ≦x≦ 2n- 1을 만족한다.출력 형식원래의 비밀지도를 해독하여'#',공백으로 구성된 문자열 배열로 출력하라.입출력 예제매개변수값n5arr1[9, 20, 28, 18, 11]arr2[30, 1, 21, 17, 28]출력[""#####"",""# # #"", ""### #"", ""#  ##"", ""#####""]매개변수값n6arr1[46, 33, 33 ,22, 31, 50]arr2[27 ,56, 19, 14, 14, 10]출력[""######"", ""###  #"", ""##  ##"", "" #### "", "" #####"", ""### # ""]해설 보러가기",1
87,[1차] 캐시,"캐시지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.입력 형식캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.cacheSize는 정수이며, 범위는 0 ≦cacheSize≦ 30 이다.cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.출력 형식입력된 도시이름 배열을 순서대로 처리할 때, ""총 실행시간""을 출력한다.조건캐시 교체 알고리즘은LRU(Least Recently Used)를 사용한다.cache hit일 경우 실행시간은1이다.cache miss일 경우 실행시간은5이다.입출력 예제캐시크기(cacheSize)도시이름(cities)실행시간3[""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""]503[""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul""]212[""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""]605[""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""]522[""Jeju"", ""Pangyo"", ""NewYork"", ""newyork""]160[""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""]25해설 보러가기",1
88,[1차] 프렌즈4블록,"프렌즈4블록블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 ""프렌즈4블록"".같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.위 초기 배치를 문자로 표시하면 아래와 같다.TTTANT
RRFACC
RRRFCC
TRRRAA
TTMMMF
TMMTTJ각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.입력 형식입력으로 판의 높이m, 폭n과 판의 배치 정보board가 들어온다.2 ≦n,m≦ 30board는 길이n인 문자열m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.출력 형식입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.입출력 예제mnboardanswer45[""CCBDE"", ""AAADE"", ""AAABF"", ""CCBBF""]1466[""TTTANT"", ""RRFACC"", ""RRRFCC"", ""TRRRAA"", ""TTMMMF"", ""TMMTTJ""]15예제에 대한 설명입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다.입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다.해설 보러가기",1
89,[1차] 셔틀버스,"셔틀버스카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.셔틀은09:00부터 총n회t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대m명의 승객이 탈 수 있다.셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어09:00에 도착한 셔틀은 자리가 있다면09:00에 줄을 선 크루도 탈 수 있다.일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.입력 형식셔틀 운행 횟수n, 셔틀 운행 간격t, 한 셔틀에 탈 수 있는 최대 크루 수m, 크루가 대기열에 도착하는 시각을 모은 배열timetable이 입력으로 주어진다.0 ＜n≦ 100 ＜t≦ 600 ＜m≦ 45timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이HH:MM형식으로 이루어져 있다.크루의 도착 시각HH:MM은00:01에서23:59사이이다.출력 형식콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은HH:MM형식이며,00:00에서23:59사이의 값이 될 수 있다.입출력 예제ntmtimetableanswer115[""08:00"", ""08:01"", ""08:02"", ""08:03""]""09:00""2102[""09:10"", ""09:09"", ""08:00""]""09:09""212[""09:00"", ""09:00"", ""09:00"", ""09:00""]""08:59""115[""00:01"", ""00:01"", ""00:01"", ""00:01"", ""00:01""]""00:00""111[""23:59""]""09:00""106045[""23:59"",""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59""]""18:00""해설 보러가기",1
90,[1차] 뉴스 클러스터링,"뉴스 클러스터링여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 ""카카오 신입 개발자 공채"" 관련 기사를 검색해보았다.카카오 첫 공채..'블라인드' 방식 채용카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용카카오, 블라인드 전형으로 신입 개발자 공채카카오 공채, 신입 개발자 코딩 능력만 본다카카오, 신입 공채.. ""코딩 실력만 본다""카카오 ""코딩 능력만으로 2018 신입 개발자 뽑는다""기사의 제목을 기준으로 ""블라인드 전형""에 주목하는 기사와 ""코딩 테스트""에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 ""자카드 유사도""라는 방법을 찾아냈다.자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합A,B사이의 자카드 유사도J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.예를 들어 집합A= {1, 2, 3}, 집합B= {2, 3, 4}라고 할 때, 교집합A ∩ B= {2, 3}, 합집합A ∪ B= {1, 2, 3, 4}이 되므로, 집합A,B사이의 자카드 유사도J(A, B)= 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로J(A, B)= 1로 정의한다.자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합A는 원소 ""1""을 3개 가지고 있고, 다중집합B는 원소 ""1""을 5개 가지고 있다고 하자. 이 다중집합의 교집합A ∩ B는 원소 ""1""을 min(3, 5)인 3개, 합집합A ∪ B는 원소 ""1""을 max(3, 5)인 5개 가지게 된다. 다중집합A= {1, 1, 2, 2, 3}, 다중집합B= {1, 2, 2, 4, 5}라고 하면, 교집합A ∩ B= {1, 2, 2}, 합집합A ∪ B= {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도J(A, B)= 3/7, 약 0.42가 된다.이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 ""FRANCE""와 ""FRENCH""가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도J(""FRANCE"", ""FRENCH"")= 2/8 = 0.25가 된다.입력 형식입력으로는str1과str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 ""ab+""가 입력으로 들어오면, ""ab""만 다중집합의 원소로 삼고, ""b+""는 버린다.다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. ""AB""와 ""Ab"", ""ab""는 같은 원소로 취급한다.출력 형식입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.예제 입출력str1str2answerFRANCEfrench16384handshakeshake hands65536aa1+aa2AAAA1243690E=M*C^2e=m*c^265536해설 보러가기",1
91,[1차] 추석 트래픽,"추석 트래픽이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다.초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.입력 형식solution함수에 전달되는lines배열은N(1 ≦N≦ 2,000)개의 로그 문자열로 되어 있으며,
각 로그 문자열마다 요청에 대한 응답완료시간S와 처리시간T가 공백으로 구분되어 있다.응답완료시간S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이2016-09-15 hh:mm:ss.sss형식으로 되어 있다.처리시간T는0.1s,0.312s,2s와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는s로 끝난다.예를 들어, 로그 문자열2016-09-15 03:10:33.020 0.011s은 ""2016년 9월 15일 오전 3시 10분33.010초""부터 ""2016년 9월 15일 오전 3시 10분33.020초""까지 ""0.011초"" 동안 처리된 요청을 의미한다.(처리시간은 시작시간과 끝시간을 포함)서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은0.001 ≦ T ≦ 3.000이다.lines배열은 응답완료시간S를 기준으로 오름차순 정렬되어 있다.출력 형식solution함수에서는 로그 데이터lines배열에 대해초당 최대 처리량을 리턴한다.입출력 예제예제1입력: [""2016-09-15 01:00:04.001 2.0s"",""2016-09-15 01:00:07.000 2s""]출력: 1예제2입력: [""2016-09-15 01:00:04.002 2.0s"",""2016-09-15 01:00:07.000 2s""]출력: 2설명: 처리시간은 시작시간과 끝시간을포함하므로첫 번째 로그는01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,두 번째 로그는01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인01:00:04.002 ~ 01:00:05.0011초 동안 최대 2개가 된다.예제3입력: [""2016-09-15 20:59:57.421 0.351s"",""2016-09-15 20:59:58.233 1.181s"",""2016-09-15 20:59:58.299 0.8s"",""2016-09-15 20:59:58.688 1.041s"",""2016-09-15 20:59:59.591 1.412s"",""2016-09-15 21:00:00.464 1.466s"",""2016-09-15 21:00:00.741 1.581s"",""2016-09-15 21:00:00.748 2.31s"",""2016-09-15 21:00:00.966 0.381s"",""2016-09-15 21:00:02.066 2.62s""]출력: 7설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면(1)은 4개,(2)는 7개,(3)는 2개임을 알 수 있다. 따라서초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.해설 보러가기",1
