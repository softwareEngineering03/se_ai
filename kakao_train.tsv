0	상금 헌터	2017년에 이어, 2018년에도 카카오 코드 페스티벌이 개최된다! 카카오 코드 페스티벌에서 빠질 수 없는 것은 바로 상금이다. 2017년에 개최된 제1회 코드 페스티벌에서는, 본선 진출자 100명 중 21명에게 아래와 같은 기준으로 상금을 부여하였다. 순위 상금 인원 1등 500만원 1명 2등 300만원 2명 3등 200만원 3명 4등 50만원 4명 5등 30만원 5명 6등 10만원 6명 2018년에 개최될 제2회 코드 페스티벌에서는 상금의 규모가 확대되어, 본선 진출자 64명 중 31명에게 아래와 같은 기준으로 상금을 부여할 예정이다. 순위 상금 인원 1등 512만원 1명 2등 256만원 2명 3등 128만원 4명 4등 64만원 8명 5등 32만원 16명 제이지는 자신이 코드 페스티벌에 출전하여 받을 수 있을 상금이 얼마인지 궁금해졌다. 그는 자신이 두 번의 코드 페스티벌 본선 대회에서 얻을 수 있을 총 상금이 얼마인지 알아보기 위해, 상상력을 발휘하여 아래와 같은 가정을 하였다. 제1회 코드 페스티벌 본선에 진출하여 a등(1 ≤ a ≤ 100)등을 하였다. 단, 진출하지 못했다면 a = 0으로 둔다. 제2회 코드 페스티벌 본선에 진출하여 b등(1 ≤ b ≤ 64)등을 할 것이다. 단, 진출하지 못했다면 b = 0으로 둔다. 제이지는 이러한 가정에 따라, 자신이 받을 수 있는 총 상금이 얼마인지를 알고 싶어한다.
1	인형들	카카오프렌즈 스토어에서는 N종류의 인형을 팔고 있다. N개의 인형들 중에서는 잘 팔리는 인형과 그렇지 않은 인형들이 섞여 있어서 잘 팔리는 인형은 상대적으로 사람들이 많이 볼 수 있는 곳에 배치하고, 잘 팔리지 않는 인형은 상대적으로 사람들이 적게 볼 수 있는 곳에 배치한다. 그러므로 배치된 곳이 가까운 두 인형은 상대적으로 판매량이 비슷하다고 할 수 있다. 좋은 배치를 정하기 위해서 어느 날, 여러 명의 사람들을 대상으로 인형의 선호도를 조사하였다. 조사 결과 각 인형에 대해서 선호하는 사람의 수를 모두 구하였고, 그에 따라 인형의 배치를 정하려고 한다. 카카오프렌즈 스토어를 관리하는 브라이언은 어떠한 특정한 곳에 인형들을 배치하고자 하는데, 그곳에 인형들을 선택하는 방법은 다음과 같다: 먼저 비슷한 인형이 가깝게 위치하도록 서로 다른 N개의 인형을 종류당 한 개씩 일렬로 배치한다. 그 후, 선호하는 사람의 수의 표준편차가 최소가 되는, K개 이상의 연속된 위치에 있는 인형들을 선택하여 그들을 같은 곳에 배치한다. 위의 방법으로 인형들을 선택했을 때, 선택된 인형들의 선호하는 사람의 수의 표준편차를 구하여라. N개의 수 a1, a2, …, aN이 주어져 있을 때, 통계학에서 (산술) 평균은 (a1 + a2 + … + aN) / N 으로 정의한다. 이를 m으로 정의하자. 또한, 분산은 ((a1 - m)2 + (a2 - m)2 + … + (aN - m)2) / N으로 정의하고, 표준 편차는 분산의 음이 아닌 제곱근으로 정의한다.
2	숏코딩	코드 페스티벌 온라인 예선에 참가하고 있던 라이언은 이제 남은 시간이 00:00:00밖에 없다는 것을 깨닫게 되었다. 라이언은 이미 머릿속에서 풀이를 구상하고 코딩도 완료했기 때문에, 이를 그대로 타이핑하기만 하면 된다. 지금 라이언은 변수들과 정수들끼리 같은지 다른지 비교하는 간단한 조건문 (conditional expression) S를 작성하고자 한다. 자세히 설명하자면, 라이언이 작성하는 변수의 이름은 영문 알파벳으로만 구성된 문자열이다. 예를 들어, kakao, COde, festival은 변수의 이름이 될 수 있지만, C0de, 2018, hello_world는 변수의 이름이 될 수 없다. 변수는 정수 값을 저장하고 있으며, 변수의 값은 해당 변수가 저장하고 있는 정수 값을 의미한다. 라이언이 작성하는 정수는 무조건 -109 이상 109 이하이다. 0을 제외한 정수는 숫자 0으로 시작하지 않으며, 0을 표기하는 유일한 방법은 0이다. 예를 들어, 라이언은 0, 123456, -987654321 과 같은 정수는 작성할 수 있지만, -0, 0123, 00000, -009876, 999999999999999와 같은 정수는 작성할 수 없다. 단항식은 변수 또는 정수이다. 라이언은 아래 두 개의 비교 연산자를 사용하여 논리식을 만든다. 같음 연산자 ==: <a>==<b>와 같이 사용하며, 두 단항식 <a>와 <b>의 값을 계산하여, 같으면 true를, 다르면 false를 반환한다. 다름 연산자 !=: <a>!=<b>와 같이 사용하며, 두 단항식 <a>와 <b>의 값을 계산하여, 다르면 true를, 같으면 false를 반환한다. 위의 두 연산자 모두, 연산자의 좌변과 우변에는 오직 단항식만이 올 수 있다. 예를 들어, (a==b)!=(b==c)는 !=의 좌변과 우변에 단항식이 아닌 논리식이 들어 있으므로 라이언이 사용하는 논리식이 아니다. 라이언은 논리곱 연산자 &&로 한 개 이상의 논리식들을 연결하여 조건문을 만든다. 연결한 논리식들이 모두 true를 반환할 때에만 true, 그렇지 않다면 false를 반환하도록 할 것이다. 연결할 때에 공백 등을 삽입하지 않는다. 예를 들어, 라이언이 세 논리식 a==b, b!=c, 1!=a를 연결하고자 한다면, a==b&&b!=c&&1!=a와 같이 연결한다. 라이언이 작성하고자 하는 조건문 S는 위 문단에서 언급한 방법으로만 만들 수 있음이 보장된다. 하지만, 라이언은 남은 시간에 비해 S의 길이가 너무 길다고 생각하여, S와 동치이면서 위에서 제시된 방법으로 만들 수 있는 길이가 가장 짧은 조건문 S'을 대신 입력할 생각이다. 두 조건문 T1과 T2가 동치라는 것은, 어떤 변수 (조건문에 등장하지 않는 모든 가능한 변수도 포함) 에 어떤 값 (라이언이 작성하지 않는 정수도 가능)을 넣더라도 T1의 참/거짓 여부와 T2의 참/거짓 여부가 같다는 것이다. 라이언을 위해, S'을 대신 구해주는 프로그램을 작성하자. S'이 여러 가지 있다면, 그 중 하나를 아무거나 구해주면 된다.
3	부스터	"최근 새로 출시되어 인기를 끌고 있는 카카오게임이 있다. 이 게임에서는 2차원 좌표 평면상에 N개의 체크포인트가 존재하며, 플레이어는 체크포인트를 오가면서 원하는 곳에 도달해야 하는 목표를 가진다. 플레이어가 조종하는 캐릭터는 최대 HP 제한 X를 가지며, 또한 부스터를 장착하고 있다. 이 캐릭터는 다음과 같은 두 가지 방법으로 이동할 수 있다. 걷기: 단순한 걷기 동작이다. 원하는 방향으로 걸어갈 수 있다. d만큼의 거리를 걸어갔을 때, 캐릭터의 HP는 d만큼 감소한다. HP가 0 미만이 될 경우 캐릭터는 죽게 된다. 부스터 사용: 플레이어는 동 / 서 / 남 / 북 4가지 방향으로 부스터를 사용할 수 있다. (동: x좌표 증가, 서: x좌표 감소, 남: y좌표 감소, 북: y좌표 증가) 부스터를 활성화하면, 캐릭터는 HP를 소모하지 않고 원하는 방향으로 날아가게 된다. 이후 플레이어가 원하는 위치에서 부스터를 종료하면, 움직임이 멈추고 캐릭터가 그 자리에 서게 된다. 부스터는 ""방전""과 ""충전""의 두 가지 상태를 가지며, 충전 상태에만 사용될 수 있다. 부스터를 종료하면, 부스터는 이동 거리에 상관없이 방전된다. 초기에, 플레이어의 HP는 X이며, 플레이어의 부스터는 방전되어 있다. 각각의 체크포인트에서 플레이어는 HP를 최대 한번 재충전할 수 있으며 (즉, 최대 HP인 X로 바꿀 수 있으며), 방전된 부스터를 최대 한번 재충전할 수 있다. 동현이는 이 게임의 개발자이며, 현재 게임의 세부 사항을 조정하고 있다. 다양한 스테이지의 개발을 위해서, 동현이는 다음과 같은 질의를 빠르게 처리해야 한다. 플레이어의 최대 HP 제한이 X일 때, 체크포인트 A에서 시작하여서 체크포인트 B로 이동할 수 있는 방법이 있는가? 동현이를 도와, 각각의 질의를 처리하라."
4	음악 추천	멜론은 국내 최다 고객과 음원을 보유한 디지털 뮤직 플랫폼이다. 멜론의 특징 중 하나는 사용자 개인별 맞춤 큐레이션 서비스로, 사용자의 취향 및 콘텐츠의 특성을 분석하여 좋아할 만한 음악을 추천함으로써 사용자가 계속해서 쓸 수 있는 서비스를 만드는 것이다. 사용자가 만족할 만한 서비스를 제공하기 위해서는 추천 알고리즘의 성능을 우수하게 유지하는 것이 중요하기 때문에, 사용자의 피드백에 따라 추천 알고리즘을 개선하거나, 좋은 성능을 보일 수 있는 새로운 추천 알고리즘을 고안하는 과정이 필요하다. 프로도는 사용자가 좋아할 만한 음악을 추천하기 위한 새로운 추천 알고리즘을 고안했다. 이 알고리즘은 음악 간 유사도를 트리의 형태로 만든 뒤 사용자의 입력에 따라 추천할 음악을 결정하는 방식이다. 예를 들어, 음악 간 유사도를 표현한 다음 트리를 살펴보자. 여기에서 각각의 노드가 곡을 나타내며, 노드의 색깔은 가수를 의미한다. 추천이 이루어지는 과정은 다음과 같다. 사용 패턴 분석을 통해 트리에 있는 노드 중 하나와 가중치가 결정되는데, 선택된 노드가 루트가 되는 서브트리의 모든 노드가 추천 대상이 된다. 이 서브트리에 속한 노드에 가중치에 따른 점수가 고르게 부여된다. 가중치가 노드의 수로 나누어떨어지지 않는 경우 몫만이 분배된다. 예를 들어, 아래 그림에서처럼 노드가 하나 선택되고 여기에 가중치 23을 부여한다고 가정해보자. 이 서브트리에 속한 노드는 총 다섯 개이고, 23을 5로 나누면 몫이 4가 되고 나머지가 3이 되기 때문에 각각의 노드에 점수 4가 부여된다. 이 점수가 높을수록 추천에서 선택될 확률이 높아진다. 이때, 특정한 가수의 곡만 추천되는 상황을 방지하기 위해 가수 별로 평균 점수를 관리하려고 한다. 위 트리에서 빨간색 벽돌 무늬로 표시된 노드가 아이유의 곡이라고 가정하자. 위의 그림과 같이 서브트리가 선택된 상황의 경우, 빨간색 노드가 총 두 개이므로 노드 하나당 4점씩 부여되어 아이유의 곡의 점수의 합은 8이 된다. 트리에서 빨간색으로 표시된 노드가 총 세 개이므로, 아이유의 곡은 평균 8/3점이 된다. 위와 같이 트리의 노드와 가중치가 선택되는 과정이 반복된다고 할 때, 가수 별 평균 점수가 주어진 목표 점수를 언제 초과하게 되는지 계산하려고 한다. 트리의 형태와 추천 알고리즘의 결과 데이터가 입력으로 주어질 때, 노드 별로 가수의 평균 점수가 목표 점수를 초과하는 시점을 계산하는 프로그램을 작성하시오.
5	프로도의 100일 준비	프로도와 네오는 곧 100일을 맞이한다. 100일이 되는 날 아무것도 하지 않았을 때 후폭풍을 도저히 감당할 자신이 없었던 프로도는 네오를 위한 작은 이벤트를 준비하기로 했다. 모든 것은 준비가 되었고 이제 종이를 잘라서 “LOVE” 라는 글자를 만드는 일만 남았다. 하지만 급하게 준비하는 바람에 ‘O’, ‘V’, ‘E’ 를 잘라낼 때 엉망으로 종이를 사용해버렸고, 남은 종이는 <그림 1>과 같은 히스토그램 모양의 직각다각형이 되어버렸다. 일이 이렇게 되어버리자 프로도는 이왕이면 자신의 사랑만큼이나 큰 ‘L’자를 잘라내고 싶어졌다. 다음은 종이의 형태에 대한 설명이다. 남은 종이는 각 변이 x축 또는 y축에 평행한 히스토그램 모양의 직각다각형이다. 이를 잘 잘라서 L-모양 직각다각형을 만들려고 한다. L-모양 직각다각형이란 꼭짓점의 수가 4 또는 6이고 각 변이 모두 x축 또는 y축에 평행한 직각다각형을 의미한다. 참고로, 꼭짓점의 수가 4인 직각다각형은 직사각형이다. 직사각형 모서리에서 조그만 직사각형을 오려내면 ‘L’ 자를 만들 수 있다. 예를 들어, 주어진 색종이가 <그림 1>에서 보인 것과 같을 때, <그림 2>. <그림 3>. <그림 4>는 서로 다른 L-모양 직각다각형을 어떻게 만들 수 있는지 보여준다. 물론 이 외에도 훨씬 더 많은 방법이 있다. 이렇게 사용하고 남은 종이가 히스토그램 모양의 직각다각형일 때, 여기서 면적이 가장 큰 L-모양 직각다각형을 구해서 프로도를 도와주자.
0	승부 예측	심심했던 무지와 콘은 TV를 보다가, 대한민국 선수단이 실시간으로 출전하고 있는 경기를 보게 되었다. 지금 보고 있는 경기는 조별리그가 진행 중인데, 대한민국이 속한 조는 총 4개 국가가 참가하여 경기가 진행되고 있다. 조별리그의 규칙은 다음과 같다. 4개의 팀이 조별리그를 진행한다. 한 팀은 자신을 제외한 모든 상대방과 한 번씩, 총 3번의 경기를 치른다. 경기의 승자는 승점 3점을 받고 비기는 경우 서로 승점 1점을 받는다. 지는 경우에는 승점을 받지 않는다. 조별리그를 모두 치른 후 승점 순으로 순위를 정하는데 승점이 같을 시에는 추첨으로 순위를 정하며, 추첨은 공평하게 진행된다. 순위를 정한 후 상위 2팀은 다음 라운드로 진출한다. 전문가들은 조별 리그의 6경기 전체에 대해서 어떤 팀이 승리할 확률, 비길 확률, 패배할 확률을 예측하였다. 무지와 콘은 모든 경기가 독립적으로 진행되었을 때 (어떠한 경기의 결과가 다른 경기의 결과에 영향을 주지 않음), 전문가들의 예상대로 진행된다면 각 팀이 조별리그를 통과하여 다음 라운드로 진출할 확률이 궁금해졌다. 하지만 무지와 콘은 직접 확률을 계산하지 못했고, 여러분들에게 도움을 요청하였다. 무지와 콘을 도와 이 문제를 해결해보자!
1	카카오머니	카카오페이는 카카오톡을 통해 송금, 결제 등을 할 수 있는 핀테크 서비스이다. 카카오페이에는 원하는 만큼 현금을 충전하고 사용할 수 있는 카카오머니라는 서비스가 있다. 무지는 오늘부터 현금을 간편하게 사용할 수 있는 카카오머니를 사용해 보기로 하였다. 무지는 좀 더 편리하게 서비스를 이용하기 위해 잔액이 10100 원인 자신의 계좌와 카카오머니 계정을 연결하였다. 처음에 무지의 카카오머니 잔액은 0원이다. 무지가 자신의 통장에서 잔액을 충전하거나 타인에게 송금을 받을 경우 카카오머니 잔액이 증가하며, 이러한 경우를 입금이라고 한다. 또한, 무지가 카카오머니로 결제를 하거나 타인에게 송금을 할 경우 카카오머니 잔액이 감소하며, 이러한 경우를 출금이라고 한다. 이 문제에서는 입금 또는 출금할 때 액수가 1원 단위여야 한다는 것 외의 별다른 제약이 없다고 가정하자. 즉, 실제 카카오머니의 제약사항인 잔액 200만 원 이하, 송금은 1일에 50만 원 한도 등은 무시한다. x 원이 입금될 경우, 무지의 카카오머니 잔액은 x 원만큼 증가한다. 그러나, x 원을 출금할 때는 상황이 다르다. 만약 잔액이 x 원 이상이라면, 잔액에서 x 원을 차감하면 된다. 그러나, 잔액이 x 원 미만이라면 카카오머니 내부에서 금액을 충당할 수 없기 때문에, 연결된 통장에서 돈을 가져올 필요가 있다. 카카오는 이를 위해 최소 충전 단위 M 을 두어서, 잔액이 x 원 이상이 되기 전까지 M 원을 통장에서 가져오다가, 잔액이 x 원 이상이 되면 x 원을 잔액에서 차감한다. M 은 양의 정수이다. 예를 들어, M = 10,000 이고 무지의 잔액이 1,500원일 때, x = 17,000원을 출금하려는 상황을 가정하여 보자. 무지의 잔액으로는 x = 17,000원을 만들 수 없기 때문에, 카카오머니는 우선 무지의 계좌에서 M = 10,000원을 가져와 잔액을 11,500원으로 만든다. 그러나, 11,500원으로도 x = 17,000원을 만들 수 없기 때문에, 카카오머니는 무지의 계좌에서 또 M = 10,000원을 가져와 잔액을 21,500원으로 만든다. 이제는 17,000원을 출금할 수 있으므로, 잔액에서 x = 17,000원을 차감한다. 최종적으로, 무지의 카카오머니 잔액은 21,500 - 17,000 = 4,500원이 된다. 카카오머니에 남는 입출금 내역과는 별개로, 무지는 카카오머니를 이용하기 시작할 때부터 자신만의 입출금 로그를 작성하였다. 이 로그는 N 개의 두 정수 쌍 (ai, bi)로 이루어져 있으며, 시간 순서대로 저장되어 있다. 무지는 꼼꼼하기 때문에 입금 또는 출금 내역을 로그에서 하나도 빠뜨리지 않았다고 생각한다. 각 쌍의 의미는 아래와 같다. ai > 0이라면, 무지의 카카오머니에 ai 원이 입금되었다. 입금 결과, 잔액은 bi 원이었다. ai < 0이라면, 무지의 카카오머니에서 -ai 원이 출금되었다. 출금 결과, 최종적으로 잔액은 bi 원이었다. ai = 0인 경우는 없다. 위에 언급된 예시의 경우, 무지의 입출금 로그에 (-17,000, 4,500)이 추가되었을 것이다. 그러나 무지는 자신이 제대로 로그를 관리하고 있는지에 대한 걱정이 들기도 해서, 간단하게 로그에 모순이 없는지를 점검해 보고자 한다. 무지가 생각한 방법은, 입출금 로그만 보고 유효한, 즉 로그에 모순이 생기지 않도록 하는 최소 충전 단위 M 이 존재하는지, 존재한다면 값이 얼마인지 확인하는 것이다. 무지를 도와, 이 일을 대신해 줄 프로그램을 작성하라.
2	뒤집기	어느 날, 네오는 길을 걷다가 격자판 하나를 주웠다. 그 격자판은 N 행 M 열로, 각 격자는 흰색 또는 검은색으로 칠해져 있다. 네오는 이 격자판에는 분명 엄청난 비밀이 숨겨져 있을 것이라고 생각해 나중에 해독을 시도해 보기로 하였다. 아래 그림은 격자판 상태의 예시이다. 네오가 잠시 외출한 사이, 프로도는 네오의 격자판을 이리저리 살펴보았다. 얼마 뒤, 하나의 격자를 누르게 되면 자신을 포함해 그 격자와 연결된 모든 칸들의 색이 반전된다는 사실을 관찰할 수 있었다. 여기서, 두 격자가 연결되었다는 것은 두 격자 사이를 서로 같은 색이면서 변을 공유하는 격자들로만 이동하여 오갈 수 있다는 것을 뜻한다. 집으로 돌아온 네오는 프로도가 격자판의 상태를 바꿔버렸다는 것을 알고 좌절했다. 하지만 최종 상태를 알고 있기 때문에, 초기 상태를 추측할 수 있을 것이라는 희망을 가지기로 했다. 프로도는 격자판을 0번 이상 눌렀다(아직 한 번도 누르지 않은 상태일 수도 있다). 현재 각 격자의 색깔이 주어졌을 때, 격자판의 초기 상태로 가능한 경우의 수를 1,000,000,007(109 + 7)로 나눈 나머지를 구하여라. 두 격자판의 상태가 다르다는 것은, 같은 위치의 격자의 색이 다른 경우가 존재할 때로 정의한다.
3	섬	자가용 비행기로 태평양 한복판을 비행하던 튜브는, 연료 부족으로 외딴섬 한가운데에 불시착하고 말았다! 다행히도, 튜브는 섬 근방의 지역에 대한 정보가 전부 나와있는 N × M 격자 모양의 지도를 발견하였다. 튜브가 발견한 지도에서, 격자의 각 셀은 전부 바다이거나 육지이며, 최외곽에 있는 셀들은 모두 바다이다. 엄밀하게 정의해서, 격자의 각 셀은 (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) 형태의 좌표로 표현되며, x = 1, x = N, y = 1, y = M 중 하나의 식이라도 만족하는 셀 (x, y)는 바다임이 보장된다. 모든 육지 셀은 어떠한 섬의 일부분인데, 두 육지 셀이 인접하다면 (한 면을 맞닿고 있다면) 이들은 하나의 섬으로 간주된다. 다른 말로, (x, y)와 (x+1, y)가 모두 육지 셀이면 둘은 같은 섬에 속하고, (x, y)와 (x, y+1)이 모두 육지 셀이면 이 둘 역시 같은 섬에 속한다. 튜브는 현재 위치에서 뗏목을 주웠고, 이 뗏목을 타고 저 멀리 망망대해로 먼 여정을 떠날 예정이다. 튜브는 임의의 셀에서 인접한 4방향의 셀로 이동할 수 있으며, 이동 시에는 해당 셀이 육지인지 바다인지의 여부는 중요하지 않다 (뗏목을 주웠으니까!). 튜브의 목표는 현재의 위치에서 이러한 이동을 통해 저 멀리 바다에서 연료를 찾아 돌아오는 것이다. 하지만 튜브는 두 가지 문제점에 봉착해 있다. 첫 번째 문제는, 튜브가 불시착한 지역에 있는 섬 중 하나의 섬에는 오리를 잡아먹으려 하는 무서운 사냥꾼들이 살고 있다. 튜브가 현재 있는 섬은 안전함을 확인했으나, 만약 탈출 시 사냥꾼이 있는 섬을 지나야 만 한다면 튜브는 큰 위험에 처하게 된다! 두 번째 문제는, 튜브가 현재 지도 상의 어느 섬에 있는지를 알지 못한다는 것이다. 튜브가 있는 섬은 최외곽의 바다와 바로 인접해있는 편리한 곳일 수도 있으나, 다른 섬들에 층층이 둘러싸인 위험한 곳일 수도 있다. 튜브는 지도상의 모든 섬에 대해서 해당 섬이 안전한지 위험한지를 알고 싶어 한다. 어떠한 섬 S 가 위험하다는 것은, S 에서 최외곽 셀로 가기 위해서 무조건 지나야 하는 S 와는 다른 섬 T 가 존재한다는 것이고, S 가 안전하다는 것은 S 가 위험하지 않다는 것을 뜻한다. 튜브를 도와서, 지도상에 있는 섬들 중 안전한 섬이 무엇이고 위험한 섬이 무엇인지 알려주자!
4	보물 상자 열기	어피치는 전설 속의 보물을 찾기 위해 여행을 떠났고, 여러 관문을 돌파한 끝에 보물이 들어 있으리라 추정되는 상자를 찾았다. 하지만 그 상자는 잠금이 걸려 있었고, 거기에는 “상자를 열려면 상자 아래의 글자들을 잘 바꾸어 앞으로 읽으나 뒤로 읽으나 똑같아지도록 하라”라는 글귀가 쓰여 있었다. 상자 근처를 탐색해 보니 상자 아래에 알파벳이 쓰여 있는 석판 여러 장이 일렬로 놓여 있었다. 또한 상자의 주위에는 알파벳이 쓰여 있는 석판이 매우 많이 있었다. 아무래도 석판들을 잘 교체하여 상자 아래 일렬로 놓인 석판들을 회문(앞에서 뒤로 읽으나 뒤에서 앞으로 읽으나 똑같은 낱말이나 숫자 또는 문장)으로 만들면 상자가 열리는 듯하다. 어피치는 체력이 얼마 없기 때문에, 소모하는 체력을 최소로 하여 보물을 얻고자 한다. 각 석판은 교체하는 데 소모되는 체력이 다르다. 또한, 한 번 이동하는 데 c 만큼 체력이 소모된다. 즉, 이전 위치가 i 번째 석판이었는데 이번에 j 번째 석판을 교체하고자 한다면 그 위치까지 이동하는 동안 c * |j - i| 의 체력이 소모된다. N 개의 석판에 대해, 각각의 석판이 있는 위치에서 시작할 때 보물을 얻기 위해 소모되는 최소 체력을 구하시오.
5	조용한 생활관 만들기	카카오 마법 학교는 건물들의 독특한 구조로 유명한데, 그중에서도 특이한 것은 학생 생활관이다. 카카오 마법 학교의 생활관은 N 개의 건물로 이루어져 있으며, N-1 개의 도로가 건물 사이를 잇고 있다. 특이한 것은 이 도로들이 모두 일방통행이라는 것이다. 자세한 구조를 설명하자면, 생활관은 입구와 출구가 있으며, 입구에는 1번 건물이 있다. 1번 건물을 제외한 각 건물에는 그 건물로 들어오는 도로가 정확히 하나 존재하며, 1번 건물로부터 각 건물까지 일방통행 도로만을 이용해서 갈 수 있다. 그리고 모든 건물에서 출구로 가는 길이 존재하는데, 생활관 규칙이 엄격하여 밤에는 출구가 폐쇄된다. 라이언은 카카오 마법 학교에서 코딩마법을 가르치는 교수이다. 요즘 그의 가장 큰 고민거리는 교수아파트 바로 옆에 있는 학생 생활관에서 발생하는 소음 때문에 잠을 이루지 못한다는 것이다. 생활관이 이렇게 시끄러운 이유는 많은 학생이 한 건물로 모여들기 때문이다. 라이언 교수는 두 도로를 이어서 한 도로로 만드는 ‘Union’ 마법을 이용해서 원래 서로 오고 갈 수 있던 건물들을 그렇지 못하게 만들어 학생들이 모이는 것을 방지하고자 한다. ‘Union’ 마법을 자세히 설명하면, 한 도로의 끝점과 다른 도로의 시작점이 같을 때 두 도로를 이어 붙이는 마법이다. 즉, 한 도로가 건물 x 에서 건물 y 로, 다른 도로가 건물 y 에서 건물 z 로 가는 도로일 때 ‘Union’ 마법을 사용하면 원래 있던 두 도로는 사라지고 건물 x 에서 z 로 가는 하나의 도로가 생긴다. 이때, 새 도로는 건물 y 를 지나지 않는다. 라이언의 목표는 생활관의 “시끄러운 정도”를 최소화하는 것이다. 생활관의 “시끄러운 정도”는 서로 다른 건물에 사는 학생 a 와 학생 b 에 대해, 학생 a 가 사는 건물에서 학생 b 가 거주하는 건물로 가는 경로가 존재하는 (a, b) 쌍의 개수이다. 앞서 말했다시피 밤에는 출구가 폐쇄되기 때문에 출구로 나갔다가 입구로 다시 들어오는 것은 불가능하다. 라이언은 오랜 기간 마법을 수련해 무제한으로 ‘Union’ 마법을 사용할 수 있다. 이때, 생활관의 “시끄러운 정도”의 가능한 최솟값을 구해 라이언을 도와주자.
6	자석 장난감	제이지는 리틀 프렌즈를 위한 장난감 세트를 출시했다. 이 장난감 세트에는 리틀 프렌즈 모양의 N 개의 동그란 자석과 M 개의 줄 모양의 자석이 있다. 동그란 자석은 서로 붙지 않고, 줄 모양 자석 역시 서로 붙지 않는다. 하지만 줄 모양 자석과 동그란 자석은 서로 붙기 때문에, 이 자석들을 모아두면 서로 다른 두 개의 동그란 자석을 줄 모양 자석이 연결하는 형태가 된다. 이 장난감 세트를 가지고 노는 방법은 이렇게 연결되어있는 동그란 자석들을 하나씩 제거해가는 것이다. 어떤 동그란 자석 X 를 제거하면 X 에 붙어있는 줄 모양 자석도 모두 제거되는데, 이때 자석 X 를 제거하기 위해서는 X 와 줄 모양 자석으로 연결되어있는 다른 모든 동그란 자석들의 모든 쌍이 줄 모양 자석으로 연결되어있어야 한다. 예를 들어, 아래 그림과 같은 자석들의 연결 상태에서는 위에서 설명한 규칙에 따라 모든 자석의 제거가 가능하다. 아래 상태 역시 모든 자석을 제거할 수 있다. 예를 들어 무지 – 어피치 – 콘 – 튜브 – 라이언의 순서로 제거할 수도 있고 다른 순서로도 가능하다. 하지만 아래 그림의 경우에는 불가능하다. 처음에 제거할 수 있는 자석이 라이언뿐인데, 그 후 다른 어떤 자석도 제거할 수 없기 때문이다. 제이지는 이 장난감 세트를 가지고 놀 리틀 프렌즈를 위해 자석들의 연결 상태가 모든 자석을 제거할 수 있는 방법이 있는지 알려주는 프로그램 역시 동봉하려고 한다. 제이지와 리틀 프렌즈를 위해 여러분이 그 프로그램을 작성해주자.
7	헬리콥터	프로도는 헬리콥터 조종 면허를 따기 위해 연습 중이다. 헬리콥터 조종 면허의 실기 시험은 2차원 XY 직교 좌표계의 수평 길이가 L 인 코스에서 치러진다. 헬리콥터는 해당 코스의 왼쪽 수평 끝 (0, 0)에서 이륙하여 오른쪽 수평 끝 (L, 0)에 착륙해야 한다. 이때 각각의 X 좌표마다 헬리콥터가 날 수 있는 비행 높이 Y 가 범위로 정해져 있는데, 실기 시험에 합격하기 위해서는 이 범위를 지키며 주어진 코스를 가능한 짧은 비행거리로 날아야 한다. 헬리콥터는 언제나 X 좌표가 증가하는 방향, 즉 왼쪽에서 오른쪽으로 이동하며 해당 X 좌표의 비행 범위 내에서 Y 좌표를 위아래로 이동할 수 있다. 단, 안전을 위해 규칙상 X 좌표와 Y 좌표를 동시에 움직여서는 안 된다. 즉 헬리콥터는 한 번에 수평 혹은 수직 방향으로만 움직여야 한다. 하지만 프로도는 딱 한 번, 면접관의 눈을 속여 X, Y 좌표가 함께 변하는 대각선 비행이 가능하다. 아래 그림은 실기 시험 코스와 그 코스에 따라 프로도가 비행할 수 있는 경로의 한 예이다. 비행거리란 헬리콥터가 나는 비행경로 선분 길이의 총합이다. 위 그림의 경로는 프로도의 헬리콥터가 날 수 있는 가장 짧은 비행거리가 아닐 수도 있다. 하늘을 날고 싶은 프로도를 위해, 조건을 만족하며 프로도의 헬리콥터가 날 수 있는 가장 짧은 비행거리를 구해주자.
